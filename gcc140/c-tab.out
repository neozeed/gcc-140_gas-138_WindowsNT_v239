Conflict in state 172 between rule 160 and token '(' resolved as shift.
Conflict in state 172 between rule 160 and token '[' resolved as shift.
Conflict in state 220 between rule 71 and token ASSIGN resolved as shift.
Conflict in state 220 between rule 71 and token '=' resolved as shift.
Conflict in state 220 between rule 71 and token '?' resolved as shift.
Conflict in state 220 between rule 71 and token OROR resolved as shift.
Conflict in state 220 between rule 71 and token ANDAND resolved as shift.
Conflict in state 220 between rule 71 and token '|' resolved as shift.
Conflict in state 220 between rule 71 and token '^' resolved as shift.
Conflict in state 220 between rule 71 and token '&' resolved as shift.
Conflict in state 220 between rule 71 and token EQCOMPARE resolved as shift.
Conflict in state 220 between rule 71 and token ARITHCOMPARE resolved as shift.
Conflict in state 220 between rule 71 and token LSHIFT resolved as shift.
Conflict in state 220 between rule 71 and token RSHIFT resolved as shift.
Conflict in state 220 between rule 71 and token '+' resolved as shift.
Conflict in state 220 between rule 71 and token '-' resolved as shift.
Conflict in state 220 between rule 71 and token '*' resolved as shift.
Conflict in state 220 between rule 71 and token '/' resolved as shift.
Conflict in state 220 between rule 71 and token '%' resolved as shift.
Conflict in state 221 between rule 70 and token ASSIGN resolved as shift.
Conflict in state 221 between rule 70 and token '=' resolved as shift.
Conflict in state 221 between rule 70 and token '?' resolved as shift.
Conflict in state 221 between rule 70 and token OROR resolved as shift.
Conflict in state 221 between rule 70 and token ANDAND resolved as shift.
Conflict in state 221 between rule 70 and token '|' resolved as shift.
Conflict in state 221 between rule 70 and token '^' resolved as shift.
Conflict in state 221 between rule 70 and token '&' resolved as shift.
Conflict in state 221 between rule 70 and token EQCOMPARE resolved as shift.
Conflict in state 221 between rule 70 and token ARITHCOMPARE resolved as shift.
Conflict in state 221 between rule 70 and token LSHIFT resolved as shift.
Conflict in state 221 between rule 70 and token RSHIFT resolved as shift.
Conflict in state 221 between rule 70 and token '+' resolved as shift.
Conflict in state 221 between rule 70 and token '-' resolved as shift.
Conflict in state 221 between rule 70 and token '*' resolved as shift.
Conflict in state 221 between rule 70 and token '/' resolved as shift.
Conflict in state 221 between rule 70 and token '%' resolved as shift.
Conflict in state 224 between rule 68 and token ASSIGN resolved as reduce.
Conflict in state 224 between rule 68 and token '=' resolved as reduce.
Conflict in state 224 between rule 68 and token '?' resolved as reduce.
Conflict in state 224 between rule 68 and token OROR resolved as reduce.
Conflict in state 224 between rule 68 and token ANDAND resolved as shift.
Conflict in state 224 between rule 68 and token '|' resolved as shift.
Conflict in state 224 between rule 68 and token '^' resolved as shift.
Conflict in state 224 between rule 68 and token '&' resolved as shift.
Conflict in state 224 between rule 68 and token EQCOMPARE resolved as shift.
Conflict in state 224 between rule 68 and token ARITHCOMPARE resolved as shift.
Conflict in state 224 between rule 68 and token LSHIFT resolved as shift.
Conflict in state 224 between rule 68 and token RSHIFT resolved as shift.
Conflict in state 224 between rule 68 and token '+' resolved as shift.
Conflict in state 224 between rule 68 and token '-' resolved as shift.
Conflict in state 224 between rule 68 and token '*' resolved as shift.
Conflict in state 224 between rule 68 and token '/' resolved as shift.
Conflict in state 224 between rule 68 and token '%' resolved as shift.
Conflict in state 225 between rule 67 and token ASSIGN resolved as reduce.
Conflict in state 225 between rule 67 and token '=' resolved as reduce.
Conflict in state 225 between rule 67 and token '?' resolved as reduce.
Conflict in state 225 between rule 67 and token OROR resolved as reduce.
Conflict in state 225 between rule 67 and token ANDAND resolved as reduce.
Conflict in state 225 between rule 67 and token '|' resolved as shift.
Conflict in state 225 between rule 67 and token '^' resolved as shift.
Conflict in state 225 between rule 67 and token '&' resolved as shift.
Conflict in state 225 between rule 67 and token EQCOMPARE resolved as shift.
Conflict in state 225 between rule 67 and token ARITHCOMPARE resolved as shift.
Conflict in state 225 between rule 67 and token LSHIFT resolved as shift.
Conflict in state 225 between rule 67 and token RSHIFT resolved as shift.
Conflict in state 225 between rule 67 and token '+' resolved as shift.
Conflict in state 225 between rule 67 and token '-' resolved as shift.
Conflict in state 225 between rule 67 and token '*' resolved as shift.
Conflict in state 225 between rule 67 and token '/' resolved as shift.
Conflict in state 225 between rule 67 and token '%' resolved as shift.
Conflict in state 226 between rule 65 and token ASSIGN resolved as reduce.
Conflict in state 226 between rule 65 and token '=' resolved as reduce.
Conflict in state 226 between rule 65 and token '?' resolved as reduce.
Conflict in state 226 between rule 65 and token OROR resolved as reduce.
Conflict in state 226 between rule 65 and token ANDAND resolved as reduce.
Conflict in state 226 between rule 65 and token '|' resolved as reduce.
Conflict in state 226 between rule 65 and token '^' resolved as shift.
Conflict in state 226 between rule 65 and token '&' resolved as shift.
Conflict in state 226 between rule 65 and token EQCOMPARE resolved as shift.
Conflict in state 226 between rule 65 and token ARITHCOMPARE resolved as shift.
Conflict in state 226 between rule 65 and token LSHIFT resolved as shift.
Conflict in state 226 between rule 65 and token RSHIFT resolved as shift.
Conflict in state 226 between rule 65 and token '+' resolved as shift.
Conflict in state 226 between rule 65 and token '-' resolved as shift.
Conflict in state 226 between rule 65 and token '*' resolved as shift.
Conflict in state 226 between rule 65 and token '/' resolved as shift.
Conflict in state 226 between rule 65 and token '%' resolved as shift.
Conflict in state 227 between rule 66 and token ASSIGN resolved as reduce.
Conflict in state 227 between rule 66 and token '=' resolved as reduce.
Conflict in state 227 between rule 66 and token '?' resolved as reduce.
Conflict in state 227 between rule 66 and token OROR resolved as reduce.
Conflict in state 227 between rule 66 and token ANDAND resolved as reduce.
Conflict in state 227 between rule 66 and token '|' resolved as reduce.
Conflict in state 227 between rule 66 and token '^' resolved as reduce.
Conflict in state 227 between rule 66 and token '&' resolved as shift.
Conflict in state 227 between rule 66 and token EQCOMPARE resolved as shift.
Conflict in state 227 between rule 66 and token ARITHCOMPARE resolved as shift.
Conflict in state 227 between rule 66 and token LSHIFT resolved as shift.
Conflict in state 227 between rule 66 and token RSHIFT resolved as shift.
Conflict in state 227 between rule 66 and token '+' resolved as shift.
Conflict in state 227 between rule 66 and token '-' resolved as shift.
Conflict in state 227 between rule 66 and token '*' resolved as shift.
Conflict in state 227 between rule 66 and token '/' resolved as shift.
Conflict in state 227 between rule 66 and token '%' resolved as shift.
Conflict in state 228 between rule 64 and token ASSIGN resolved as reduce.
Conflict in state 228 between rule 64 and token '=' resolved as reduce.
Conflict in state 228 between rule 64 and token '?' resolved as reduce.
Conflict in state 228 between rule 64 and token OROR resolved as reduce.
Conflict in state 228 between rule 64 and token ANDAND resolved as reduce.
Conflict in state 228 between rule 64 and token '|' resolved as reduce.
Conflict in state 228 between rule 64 and token '^' resolved as reduce.
Conflict in state 228 between rule 64 and token '&' resolved as reduce.
Conflict in state 228 between rule 64 and token EQCOMPARE resolved as shift.
Conflict in state 228 between rule 64 and token ARITHCOMPARE resolved as shift.
Conflict in state 228 between rule 64 and token LSHIFT resolved as shift.
Conflict in state 228 between rule 64 and token RSHIFT resolved as shift.
Conflict in state 228 between rule 64 and token '+' resolved as shift.
Conflict in state 228 between rule 64 and token '-' resolved as shift.
Conflict in state 228 between rule 64 and token '*' resolved as shift.
Conflict in state 228 between rule 64 and token '/' resolved as shift.
Conflict in state 228 between rule 64 and token '%' resolved as shift.
Conflict in state 229 between rule 63 and token ASSIGN resolved as reduce.
Conflict in state 229 between rule 63 and token '=' resolved as reduce.
Conflict in state 229 between rule 63 and token '?' resolved as reduce.
Conflict in state 229 between rule 63 and token OROR resolved as reduce.
Conflict in state 229 between rule 63 and token ANDAND resolved as reduce.
Conflict in state 229 between rule 63 and token '|' resolved as reduce.
Conflict in state 229 between rule 63 and token '^' resolved as reduce.
Conflict in state 229 between rule 63 and token '&' resolved as reduce.
Conflict in state 229 between rule 63 and token EQCOMPARE resolved as reduce.
Conflict in state 229 between rule 63 and token ARITHCOMPARE resolved as shift.
Conflict in state 229 between rule 63 and token LSHIFT resolved as shift.
Conflict in state 229 between rule 63 and token RSHIFT resolved as shift.
Conflict in state 229 between rule 63 and token '+' resolved as shift.
Conflict in state 229 between rule 63 and token '-' resolved as shift.
Conflict in state 229 between rule 63 and token '*' resolved as shift.
Conflict in state 229 between rule 63 and token '/' resolved as shift.
Conflict in state 229 between rule 63 and token '%' resolved as shift.
Conflict in state 230 between rule 62 and token ASSIGN resolved as reduce.
Conflict in state 230 between rule 62 and token '=' resolved as reduce.
Conflict in state 230 between rule 62 and token '?' resolved as reduce.
Conflict in state 230 between rule 62 and token OROR resolved as reduce.
Conflict in state 230 between rule 62 and token ANDAND resolved as reduce.
Conflict in state 230 between rule 62 and token '|' resolved as reduce.
Conflict in state 230 between rule 62 and token '^' resolved as reduce.
Conflict in state 230 between rule 62 and token '&' resolved as reduce.
Conflict in state 230 between rule 62 and token EQCOMPARE resolved as reduce.
Conflict in state 230 between rule 62 and token ARITHCOMPARE resolved as reduce.
Conflict in state 230 between rule 62 and token LSHIFT resolved as shift.
Conflict in state 230 between rule 62 and token RSHIFT resolved as shift.
Conflict in state 230 between rule 62 and token '+' resolved as shift.
Conflict in state 230 between rule 62 and token '-' resolved as shift.
Conflict in state 230 between rule 62 and token '*' resolved as shift.
Conflict in state 230 between rule 62 and token '/' resolved as shift.
Conflict in state 230 between rule 62 and token '%' resolved as shift.
Conflict in state 231 between rule 60 and token ASSIGN resolved as reduce.
Conflict in state 231 between rule 60 and token '=' resolved as reduce.
Conflict in state 231 between rule 60 and token '?' resolved as reduce.
Conflict in state 231 between rule 60 and token OROR resolved as reduce.
Conflict in state 231 between rule 60 and token ANDAND resolved as reduce.
Conflict in state 231 between rule 60 and token '|' resolved as reduce.
Conflict in state 231 between rule 60 and token '^' resolved as reduce.
Conflict in state 231 between rule 60 and token '&' resolved as reduce.
Conflict in state 231 between rule 60 and token EQCOMPARE resolved as reduce.
Conflict in state 231 between rule 60 and token ARITHCOMPARE resolved as reduce.
Conflict in state 231 between rule 60 and token LSHIFT resolved as reduce.
Conflict in state 231 between rule 60 and token RSHIFT resolved as reduce.
Conflict in state 231 between rule 60 and token '+' resolved as shift.
Conflict in state 231 between rule 60 and token '-' resolved as shift.
Conflict in state 231 between rule 60 and token '*' resolved as shift.
Conflict in state 231 between rule 60 and token '/' resolved as shift.
Conflict in state 231 between rule 60 and token '%' resolved as shift.
Conflict in state 232 between rule 61 and token ASSIGN resolved as reduce.
Conflict in state 232 between rule 61 and token '=' resolved as reduce.
Conflict in state 232 between rule 61 and token '?' resolved as reduce.
Conflict in state 232 between rule 61 and token OROR resolved as reduce.
Conflict in state 232 between rule 61 and token ANDAND resolved as reduce.
Conflict in state 232 between rule 61 and token '|' resolved as reduce.
Conflict in state 232 between rule 61 and token '^' resolved as reduce.
Conflict in state 232 between rule 61 and token '&' resolved as reduce.
Conflict in state 232 between rule 61 and token EQCOMPARE resolved as reduce.
Conflict in state 232 between rule 61 and token ARITHCOMPARE resolved as reduce.
Conflict in state 232 between rule 61 and token LSHIFT resolved as reduce.
Conflict in state 232 between rule 61 and token RSHIFT resolved as reduce.
Conflict in state 232 between rule 61 and token '+' resolved as shift.
Conflict in state 232 between rule 61 and token '-' resolved as shift.
Conflict in state 232 between rule 61 and token '*' resolved as shift.
Conflict in state 232 between rule 61 and token '/' resolved as shift.
Conflict in state 232 between rule 61 and token '%' resolved as shift.
Conflict in state 233 between rule 55 and token ASSIGN resolved as reduce.
Conflict in state 233 between rule 55 and token '=' resolved as reduce.
Conflict in state 233 between rule 55 and token '?' resolved as reduce.
Conflict in state 233 between rule 55 and token OROR resolved as reduce.
Conflict in state 233 between rule 55 and token ANDAND resolved as reduce.
Conflict in state 233 between rule 55 and token '|' resolved as reduce.
Conflict in state 233 between rule 55 and token '^' resolved as reduce.
Conflict in state 233 between rule 55 and token '&' resolved as reduce.
Conflict in state 233 between rule 55 and token EQCOMPARE resolved as reduce.
Conflict in state 233 between rule 55 and token ARITHCOMPARE resolved as reduce.
Conflict in state 233 between rule 55 and token LSHIFT resolved as reduce.
Conflict in state 233 between rule 55 and token RSHIFT resolved as reduce.
Conflict in state 233 between rule 55 and token '+' resolved as reduce.
Conflict in state 233 between rule 55 and token '-' resolved as reduce.
Conflict in state 233 between rule 55 and token '*' resolved as shift.
Conflict in state 233 between rule 55 and token '/' resolved as shift.
Conflict in state 233 between rule 55 and token '%' resolved as shift.
Conflict in state 234 between rule 56 and token ASSIGN resolved as reduce.
Conflict in state 234 between rule 56 and token '=' resolved as reduce.
Conflict in state 234 between rule 56 and token '?' resolved as reduce.
Conflict in state 234 between rule 56 and token OROR resolved as reduce.
Conflict in state 234 between rule 56 and token ANDAND resolved as reduce.
Conflict in state 234 between rule 56 and token '|' resolved as reduce.
Conflict in state 234 between rule 56 and token '^' resolved as reduce.
Conflict in state 234 between rule 56 and token '&' resolved as reduce.
Conflict in state 234 between rule 56 and token EQCOMPARE resolved as reduce.
Conflict in state 234 between rule 56 and token ARITHCOMPARE resolved as reduce.
Conflict in state 234 between rule 56 and token LSHIFT resolved as reduce.
Conflict in state 234 between rule 56 and token RSHIFT resolved as reduce.
Conflict in state 234 between rule 56 and token '+' resolved as reduce.
Conflict in state 234 between rule 56 and token '-' resolved as reduce.
Conflict in state 234 between rule 56 and token '*' resolved as shift.
Conflict in state 234 between rule 56 and token '/' resolved as shift.
Conflict in state 234 between rule 56 and token '%' resolved as shift.
Conflict in state 235 between rule 57 and token ASSIGN resolved as reduce.
Conflict in state 235 between rule 57 and token '=' resolved as reduce.
Conflict in state 235 between rule 57 and token '?' resolved as reduce.
Conflict in state 235 between rule 57 and token OROR resolved as reduce.
Conflict in state 235 between rule 57 and token ANDAND resolved as reduce.
Conflict in state 235 between rule 57 and token '|' resolved as reduce.
Conflict in state 235 between rule 57 and token '^' resolved as reduce.
Conflict in state 235 between rule 57 and token '&' resolved as reduce.
Conflict in state 235 between rule 57 and token EQCOMPARE resolved as reduce.
Conflict in state 235 between rule 57 and token ARITHCOMPARE resolved as reduce.
Conflict in state 235 between rule 57 and token LSHIFT resolved as reduce.
Conflict in state 235 between rule 57 and token RSHIFT resolved as reduce.
Conflict in state 235 between rule 57 and token '+' resolved as reduce.
Conflict in state 235 between rule 57 and token '-' resolved as reduce.
Conflict in state 235 between rule 57 and token '*' resolved as reduce.
Conflict in state 235 between rule 57 and token '/' resolved as reduce.
Conflict in state 235 between rule 57 and token '%' resolved as reduce.
Conflict in state 236 between rule 58 and token ASSIGN resolved as reduce.
Conflict in state 236 between rule 58 and token '=' resolved as reduce.
Conflict in state 236 between rule 58 and token '?' resolved as reduce.
Conflict in state 236 between rule 58 and token OROR resolved as reduce.
Conflict in state 236 between rule 58 and token ANDAND resolved as reduce.
Conflict in state 236 between rule 58 and token '|' resolved as reduce.
Conflict in state 236 between rule 58 and token '^' resolved as reduce.
Conflict in state 236 between rule 58 and token '&' resolved as reduce.
Conflict in state 236 between rule 58 and token EQCOMPARE resolved as reduce.
Conflict in state 236 between rule 58 and token ARITHCOMPARE resolved as reduce.
Conflict in state 236 between rule 58 and token LSHIFT resolved as reduce.
Conflict in state 236 between rule 58 and token RSHIFT resolved as reduce.
Conflict in state 236 between rule 58 and token '+' resolved as reduce.
Conflict in state 236 between rule 58 and token '-' resolved as reduce.
Conflict in state 236 between rule 58 and token '*' resolved as reduce.
Conflict in state 236 between rule 58 and token '/' resolved as reduce.
Conflict in state 236 between rule 58 and token '%' resolved as reduce.
Conflict in state 237 between rule 59 and token ASSIGN resolved as reduce.
Conflict in state 237 between rule 59 and token '=' resolved as reduce.
Conflict in state 237 between rule 59 and token '?' resolved as reduce.
Conflict in state 237 between rule 59 and token OROR resolved as reduce.
Conflict in state 237 between rule 59 and token ANDAND resolved as reduce.
Conflict in state 237 between rule 59 and token '|' resolved as reduce.
Conflict in state 237 between rule 59 and token '^' resolved as reduce.
Conflict in state 237 between rule 59 and token '&' resolved as reduce.
Conflict in state 237 between rule 59 and token EQCOMPARE resolved as reduce.
Conflict in state 237 between rule 59 and token ARITHCOMPARE resolved as reduce.
Conflict in state 237 between rule 59 and token LSHIFT resolved as reduce.
Conflict in state 237 between rule 59 and token RSHIFT resolved as reduce.
Conflict in state 237 between rule 59 and token '+' resolved as reduce.
Conflict in state 237 between rule 59 and token '-' resolved as reduce.
Conflict in state 237 between rule 59 and token '*' resolved as reduce.
Conflict in state 237 between rule 59 and token '/' resolved as reduce.
Conflict in state 237 between rule 59 and token '%' resolved as reduce.
Conflict in state 243 between rule 209 and token '(' resolved as shift.
Conflict in state 243 between rule 209 and token '[' resolved as shift.
Conflict in state 274 between rule 151 and token '(' resolved as shift.
Conflict in state 274 between rule 151 and token '[' resolved as shift.
Conflict in state 304 between rule 208 and token '(' resolved as shift.
Conflict in state 304 between rule 208 and token '[' resolved as shift.
Conflict in state 366 between rule 235 and token ELSE resolved as shift.
Conflict in state 373 between rule 69 and token ASSIGN resolved as reduce.
Conflict in state 373 between rule 69 and token '=' resolved as reduce.
Conflict in state 373 between rule 69 and token '?' resolved as shift.
Conflict in state 373 between rule 69 and token OROR resolved as shift.
Conflict in state 373 between rule 69 and token ANDAND resolved as shift.
Conflict in state 373 between rule 69 and token '|' resolved as shift.
Conflict in state 373 between rule 69 and token '^' resolved as shift.
Conflict in state 373 between rule 69 and token '&' resolved as shift.
Conflict in state 373 between rule 69 and token EQCOMPARE resolved as shift.
Conflict in state 373 between rule 69 and token ARITHCOMPARE resolved as shift.
Conflict in state 373 between rule 69 and token LSHIFT resolved as shift.
Conflict in state 373 between rule 69 and token RSHIFT resolved as shift.
Conflict in state 373 between rule 69 and token '+' resolved as shift.
Conflict in state 373 between rule 69 and token '-' resolved as shift.
Conflict in state 373 between rule 69 and token '*' resolved as shift.
Conflict in state 373 between rule 69 and token '/' resolved as shift.
Conflict in state 373 between rule 69 and token '%' resolved as shift.
Conflict in state 377 between rule 209 and token '(' resolved as shift.
Conflict in state 377 between rule 209 and token '[' resolved as shift.
Conflict in state 380 between rule 209 and token '(' resolved as shift.
Conflict in state 380 between rule 209 and token '[' resolved as shift.
Conflict in state 423 between rule 156 and token '(' resolved as shift.
Conflict in state 423 between rule 156 and token '[' resolved as shift.
State 41 contains 1 shift/reduce conflict.
State 93 contains 1 shift/reduce conflict.
State 100 contains 1 shift/reduce conflict.
State 104 contains 1 shift/reduce conflict.
State 120 contains 1 shift/reduce conflict.
State 184 contains 1 shift/reduce conflict.
State 195 contains 1 shift/reduce conflict.
State 201 contains 1 shift/reduce conflict.

Grammar
rule 1    program ->		/* empty */
rule 2    program -> extdefs
rule 3    @1 ->		/* empty */
rule 4    extdefs -> @1 extdef
rule 5    @2 ->		/* empty */
rule 6    extdefs -> extdefs @2 extdef
rule 7    extdef -> fndef
rule 8    extdef -> datadef
rule 9    extdef -> ASM '(' string ')' ';'
rule 10   datadef -> setspecs notype_initdecls ';'
rule 11   datadef -> declmods setspecs notype_initdecls ';'
rule 12   datadef -> typed_declspecs setspecs initdecls ';'
rule 13   datadef -> declmods ';'
rule 14   datadef -> typed_declspecs ';'
rule 15   datadef -> error ';'
rule 16   datadef -> error '}'
rule 17   datadef -> ';'
rule 18   @3 ->		/* empty */
rule 19   @4 ->		/* empty */
rule 20   fndef -> typed_declspecs setspecs declarator @3 xdecls @4 compstmt_or_error
rule 21   fndef -> typed_declspecs setspecs declarator error
rule 22   @5 ->		/* empty */
rule 23   @6 ->		/* empty */
rule 24   fndef -> declmods setspecs notype_declarator @5 xdecls @6 compstmt_or_error
rule 25   fndef -> declmods setspecs notype_declarator error
rule 26   @7 ->		/* empty */
rule 27   @8 ->		/* empty */
rule 28   fndef -> setspecs notype_declarator @7 xdecls @8 compstmt_or_error
rule 29   fndef -> setspecs notype_declarator error
rule 30   identifier -> IDENTIFIER
rule 31   identifier -> TYPENAME
rule 32   unop -> '&'
rule 33   unop -> '-'
rule 34   unop -> '+'
rule 35   unop -> PLUSPLUS
rule 36   unop -> MINUSMINUS
rule 37   unop -> '~'
rule 38   unop -> '!'
rule 39   expr -> nonnull_exprlist
rule 40   exprlist ->		/* empty */
rule 41   exprlist -> nonnull_exprlist
rule 42   nonnull_exprlist -> expr_no_commas
rule 43   nonnull_exprlist -> nonnull_exprlist ',' expr_no_commas
rule 44   unary_expr -> primary
rule 45   unary_expr -> '*' cast_expr
rule 46   unary_expr -> unop cast_expr
rule 47   unary_expr -> SIZEOF unary_expr
rule 48   unary_expr -> SIZEOF '(' typename ')'
rule 49   unary_expr -> ALIGNOF unary_expr
rule 50   unary_expr -> ALIGNOF '(' typename ')'
rule 51   cast_expr -> unary_expr
rule 52   cast_expr -> '(' typename ')' cast_expr
rule 53   cast_expr -> '(' typename ')' '{' initlist maybecomma '}'
rule 54   expr_no_commas -> cast_expr
rule 55   expr_no_commas -> expr_no_commas '+' expr_no_commas
rule 56   expr_no_commas -> expr_no_commas '-' expr_no_commas
rule 57   expr_no_commas -> expr_no_commas '*' expr_no_commas
rule 58   expr_no_commas -> expr_no_commas '/' expr_no_commas
rule 59   expr_no_commas -> expr_no_commas '%' expr_no_commas
rule 60   expr_no_commas -> expr_no_commas LSHIFT expr_no_commas
rule 61   expr_no_commas -> expr_no_commas RSHIFT expr_no_commas
rule 62   expr_no_commas -> expr_no_commas ARITHCOMPARE expr_no_commas
rule 63   expr_no_commas -> expr_no_commas EQCOMPARE expr_no_commas
rule 64   expr_no_commas -> expr_no_commas '&' expr_no_commas
rule 65   expr_no_commas -> expr_no_commas '|' expr_no_commas
rule 66   expr_no_commas -> expr_no_commas '^' expr_no_commas
rule 67   expr_no_commas -> expr_no_commas ANDAND expr_no_commas
rule 68   expr_no_commas -> expr_no_commas OROR expr_no_commas
rule 69   expr_no_commas -> expr_no_commas '?' xexpr ':' expr_no_commas
rule 70   expr_no_commas -> expr_no_commas '=' expr_no_commas
rule 71   expr_no_commas -> expr_no_commas ASSIGN expr_no_commas
rule 72   primary -> IDENTIFIER
rule 73   primary -> CONSTANT
rule 74   primary -> string
rule 75   primary -> '(' expr ')'
rule 76   primary -> '(' error ')'
rule 77   @9 ->		/* empty */
rule 78   primary -> '(' @9 compstmt ')'
rule 79   primary -> primary '(' exprlist ')'
rule 80   primary -> primary '[' expr ']'
rule 81   primary -> primary '.' identifier
rule 82   primary -> primary POINTSAT identifier
rule 83   primary -> primary PLUSPLUS
rule 84   primary -> primary MINUSMINUS
rule 85   string -> STRING
rule 86   string -> string STRING
rule 87   xdecls ->		/* empty */
rule 88   xdecls -> decls
rule 89   decls -> decl
rule 90   decls -> errstmt
rule 91   decls -> decls decl
rule 92   decls -> decl errstmt
rule 93   setspecs ->		/* empty */
rule 94   decl -> typed_declspecs setspecs initdecls ';'
rule 95   decl -> declmods setspecs notype_initdecls ';'
rule 96   decl -> typed_declspecs ';'
rule 97   decl -> declmods ';'
rule 98   typed_declspecs -> typespec reserved_declspecs
rule 99   typed_declspecs -> declmods typespec reserved_declspecs
rule 100  reserved_declspecs ->		/* empty */
rule 101  reserved_declspecs -> reserved_declspecs typespecqual_reserved
rule 102  reserved_declspecs -> reserved_declspecs SCSPEC
rule 103  declmods -> TYPE_QUAL
rule 104  declmods -> SCSPEC
rule 105  declmods -> declmods TYPE_QUAL
rule 106  declmods -> declmods SCSPEC
rule 107  typed_typespecs -> typespec reserved_typespecquals
rule 108  typed_typespecs -> nonempty_type_quals typespec reserved_typespecquals
rule 109  reserved_typespecquals ->		/* empty */
rule 110  reserved_typespecquals -> reserved_typespecquals typespecqual_reserved
rule 111  typespec -> TYPESPEC
rule 112  typespec -> structsp
rule 113  typespec -> TYPENAME
rule 114  typespec -> TYPEOF '(' expr ')'
rule 115  typespec -> TYPEOF '(' typename ')'
rule 116  typespecqual_reserved -> TYPESPEC
rule 117  typespecqual_reserved -> TYPE_QUAL
rule 118  typespecqual_reserved -> structsp
rule 119  initdecls -> initdcl
rule 120  initdecls -> initdecls ',' initdcl
rule 121  notype_initdecls -> notype_initdcl
rule 122  notype_initdecls -> notype_initdecls ',' initdcl
rule 123  maybeasm ->		/* empty */
rule 124  maybeasm -> ASM '(' string ')'
rule 125  @10 ->		/* empty */
rule 126  initdcl -> declarator maybeasm maybe_attribute '=' @10 init
rule 127  initdcl -> declarator maybeasm maybe_attribute
rule 128  @11 ->		/* empty */
rule 129  notype_initdcl -> notype_declarator maybeasm maybe_attribute '=' @11 init
rule 130  notype_initdcl -> notype_declarator maybeasm maybe_attribute
rule 131  maybe_attribute ->		/* empty */
rule 132  maybe_attribute -> ATTRIBUTE '(' '(' attribute_list ')' ')'
rule 133  attribute_list -> attrib
rule 134  attribute_list -> attribute_list ',' attrib
rule 135  attrib -> IDENTIFIER
rule 136  attrib -> IDENTIFIER '(' CONSTANT ')'
rule 137  attrib -> IDENTIFIER '(' identifiers ')'
rule 138  init -> expr_no_commas
rule 139  init -> '{' '}'
rule 140  init -> '{' initlist '}'
rule 141  init -> '{' initlist ',' '}'
rule 142  init -> error
rule 143  initlist -> init
rule 144  initlist -> initlist ',' init
rule 145  declarator -> after_type_declarator
rule 146  declarator -> notype_declarator
rule 147  after_type_declarator -> '(' after_type_declarator ')'
rule 148  after_type_declarator -> after_type_declarator '(' parmlist_or_identifiers
rule 149  after_type_declarator -> after_type_declarator '[' expr ']'
rule 150  after_type_declarator -> after_type_declarator '[' ']'
rule 151  after_type_declarator -> '*' type_quals after_type_declarator
rule 152  after_type_declarator -> TYPENAME
rule 153  parm_declarator -> parm_declarator '(' parmlist_or_identifiers
rule 154  parm_declarator -> parm_declarator '[' expr ']'
rule 155  parm_declarator -> parm_declarator '[' ']'
rule 156  parm_declarator -> '*' type_quals parm_declarator
rule 157  parm_declarator -> TYPENAME
rule 158  notype_declarator -> notype_declarator '(' parmlist_or_identifiers
rule 159  notype_declarator -> '(' notype_declarator ')'
rule 160  notype_declarator -> '*' type_quals notype_declarator
rule 161  notype_declarator -> notype_declarator '[' expr ']'
rule 162  notype_declarator -> notype_declarator '[' ']'
rule 163  notype_declarator -> IDENTIFIER
rule 164  @12 ->		/* empty */
rule 165  structsp -> STRUCT identifier '{' @12 component_decl_list '}'
rule 166  structsp -> STRUCT '{' component_decl_list '}'
rule 167  structsp -> STRUCT identifier
rule 168  @13 ->		/* empty */
rule 169  structsp -> UNION identifier '{' @13 component_decl_list '}'
rule 170  structsp -> UNION '{' component_decl_list '}'
rule 171  structsp -> UNION identifier
rule 172  @14 ->		/* empty */
rule 173  structsp -> ENUM identifier '{' @14 enumlist maybecomma_warn '}'
rule 174  @15 ->		/* empty */
rule 175  structsp -> ENUM '{' @15 enumlist maybecomma_warn '}'
rule 176  structsp -> ENUM identifier
rule 177  maybecomma ->		/* empty */
rule 178  maybecomma -> ','
rule 179  maybecomma_warn ->		/* empty */
rule 180  maybecomma_warn -> ','
rule 181  component_decl_list -> component_decl_list2
rule 182  component_decl_list -> component_decl_list2 component_decl
rule 183  component_decl_list2 ->		/* empty */
rule 184  component_decl_list2 -> component_decl_list2 component_decl ';'
rule 185  component_decl_list2 -> component_decl_list2 ';'
rule 186  component_decl -> typed_typespecs setspecs components
rule 187  component_decl -> nonempty_type_quals setspecs components
rule 188  component_decl -> error
rule 189  components ->		/* empty */
rule 190  components -> component_declarator
rule 191  components -> components ',' component_declarator
rule 192  component_declarator -> declarator maybe_attribute
rule 193  component_declarator -> declarator ':' expr_no_commas maybe_attribute
rule 194  component_declarator -> ':' expr_no_commas
rule 195  enumlist -> enumerator
rule 196  enumlist -> enumlist ',' enumerator
rule 197  enumerator -> identifier
rule 198  enumerator -> identifier '=' expr_no_commas
rule 199  typename -> typed_typespecs absdcl
rule 200  typename -> nonempty_type_quals absdcl
rule 201  absdcl ->		/* empty */
rule 202  absdcl -> absdcl1
rule 203  nonempty_type_quals -> TYPE_QUAL
rule 204  nonempty_type_quals -> nonempty_type_quals TYPE_QUAL
rule 205  type_quals ->		/* empty */
rule 206  type_quals -> type_quals TYPE_QUAL
rule 207  absdcl1 -> '(' absdcl1 ')'
rule 208  absdcl1 -> '*' type_quals absdcl1
rule 209  absdcl1 -> '*' type_quals
rule 210  absdcl1 -> absdcl1 '(' parmlist
rule 211  absdcl1 -> absdcl1 '[' expr ']'
rule 212  absdcl1 -> absdcl1 '[' ']'
rule 213  absdcl1 -> '(' parmlist
rule 214  absdcl1 -> '[' expr ']'
rule 215  absdcl1 -> '[' ']'
rule 216  stmts -> stmt
rule 217  stmts -> stmts stmt
rule 218  stmts -> stmts errstmt
rule 219  xstmts ->		/* empty */
rule 220  xstmts -> stmts
rule 221  errstmt -> error ';'
rule 222  pushlevel ->		/* empty */
rule 223  compstmt_or_error -> compstmt
rule 224  compstmt_or_error -> error compstmt
rule 225  compstmt -> '{' '}'
rule 226  compstmt -> '{' pushlevel decls xstmts '}'
rule 227  compstmt -> '{' pushlevel error '}'
rule 228  compstmt -> '{' pushlevel stmts '}'
rule 229  @16 ->		/* empty */
rule 230  simple_if -> IF '(' expr ')' @16 stmt
rule 231  stmt -> compstmt
rule 232  stmt -> expr ';'
rule 233  @17 ->		/* empty */
rule 234  stmt -> simple_if ELSE @17 stmt
rule 235  stmt -> simple_if
rule 236  @18 ->		/* empty */
rule 237  @19 ->		/* empty */
rule 238  stmt -> WHILE @18 '(' expr ')' @19 stmt
rule 239  @20 ->		/* empty */
rule 240  @21 ->		/* empty */
rule 241  stmt -> DO @20 stmt WHILE @21 '(' expr ')' ';'
rule 242  @22 ->		/* empty */
rule 243  @23 ->		/* empty */
rule 244  @24 ->		/* empty */
rule 245  stmt -> FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt
rule 246  @25 ->		/* empty */
rule 247  stmt -> SWITCH '(' expr ')' @25 stmt
rule 248  @26 ->		/* empty */
rule 249  stmt -> CASE expr ':' @26 stmt
rule 250  @27 ->		/* empty */
rule 251  stmt -> DEFAULT ':' @27 stmt
rule 252  stmt -> BREAK ';'
rule 253  stmt -> CONTINUE ';'
rule 254  stmt -> RETURN ';'
rule 255  stmt -> RETURN expr ';'
rule 256  stmt -> ASM maybe_type_qual '(' string ')' ';'
rule 257  stmt -> ASM maybe_type_qual '(' string ':' asm_operands ')' ';'
rule 258  stmt -> ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';'
rule 259  stmt -> ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ':' asm_clobbers ')' ';'
rule 260  stmt -> GOTO identifier ';'
rule 261  @28 ->		/* empty */
rule 262  stmt -> identifier ':' @28 stmt
rule 263  stmt -> ';'
rule 264  maybe_type_qual ->		/* empty */
rule 265  maybe_type_qual -> TYPE_QUAL
rule 266  xexpr ->		/* empty */
rule 267  xexpr -> expr
rule 268  asm_operands ->		/* empty */
rule 269  asm_operands -> nonnull_asm_operands
rule 270  nonnull_asm_operands -> asm_operand
rule 271  nonnull_asm_operands -> nonnull_asm_operands ',' asm_operand
rule 272  asm_operand -> STRING '(' expr ')'
rule 273  asm_clobbers -> string
rule 274  asm_clobbers -> asm_clobbers ',' string
rule 275  @29 ->		/* empty */
rule 276  parmlist -> @29 parmlist_1
rule 277  @30 ->		/* empty */
rule 278  parmlist_or_identifiers -> @30 parmlist_or_identifiers_1
rule 279  parmlist_or_identifiers_1 -> parmlist_2 ')'
rule 280  parmlist_or_identifiers_1 -> identifiers ')'
rule 281  parmlist_or_identifiers_1 -> error ')'
rule 282  parmlist_1 -> parmlist_2 ')'
rule 283  parmlist_1 -> error ')'
rule 284  parmlist_2 ->		/* empty */
rule 285  parmlist_2 -> parms
rule 286  parmlist_2 -> parms ',' ELLIPSIS
rule 287  parms -> parm
rule 288  parms -> parms ',' parm
rule 289  parm -> typed_declspecs parm_declarator
rule 290  parm -> typed_declspecs notype_declarator
rule 291  parm -> typed_declspecs absdcl
rule 292  parm -> declmods notype_declarator
rule 293  parm -> declmods absdcl
rule 294  identifiers -> IDENTIFIER
rule 295  identifiers -> identifiers ',' IDENTIFIER

Terminals, with rules where they appear

$ (-1)
'!' (33) 38
'%' (37) 59
'&' (38) 32 64
'(' (40) 9 48 50 52 53 75 76 78 79 114 115 124 132 136 137 147 148
    153 158 159 207 210 213 230 238 241 245 247 256 257 258 259 272
')' (41) 9 48 50 52 53 75 76 78 79 114 115 124 132 136 137 147 159
    207 230 238 241 245 247 256 257 258 259 272 279 280 281 282 283
'*' (42) 45 57 151 156 160 208 209
'+' (43) 34 55
',' (44) 43 120 122 134 141 144 178 180 191 196 271 274 286 288 295
'-' (45) 33 56
'.' (46) 81
'/' (47) 58
':' (58) 69 193 194 249 251 257 258 259 262
';' (59) 9 10 11 12 13 14 15 17 94 95 96 97 184 185 221 232 241 245
    252 253 254 255 256 257 258 259 260 263
'=' (61) 70 126 129 198
'?' (63) 69
'[' (91) 80 149 150 154 155 161 162 211 212 214 215
']' (93) 80 149 150 154 155 161 162 211 212 214 215
'^' (94) 66
'{' (123) 53 139 140 141 165 166 169 170 173 175 225 226 227 228
'|' (124) 65
'}' (125) 16 53 139 140 141 165 166 169 170 173 175 225 226 227 228
'~' (126) 37
error (256) 15 16 21 25 29 76 142 188 221 224 227 281 283
IDENTIFIER (258) 30 72 135 136 137 163 294 295
TYPENAME (259) 31 113 152 157
SCSPEC (260) 102 104 106
TYPESPEC (261) 111 116
TYPE_QUAL (262) 103 105 117 203 204 206 265
CONSTANT (263) 73 136
STRING (264) 85 86 272
ELLIPSIS (265) 286
SIZEOF (266) 47 48
ENUM (267) 173 175 176
STRUCT (268) 165 166 167
UNION (269) 169 170 171
IF (270) 230
ELSE (271) 234
WHILE (272) 238 241
DO (273) 241
FOR (274) 245
SWITCH (275) 247
CASE (276) 249
DEFAULT (277) 251
BREAK (278) 252
CONTINUE (279) 253
RETURN (280) 254 255
GOTO (281) 260
ASM (282) 9 124 256 257 258 259
TYPEOF (283) 114 115
ALIGNOF (284) 49 50
ATTRIBUTE (285) 132
ASSIGN (286) 71
OROR (287) 68
ANDAND (288) 67
EQCOMPARE (289) 63
ARITHCOMPARE (290) 62
LSHIFT (291) 60
RSHIFT (292) 61
UNARY (293)
PLUSPLUS (294) 35 83
MINUSMINUS (295) 36 84
HYPERUNARY (296)
POINTSAT (297) 82

Nonterminals, with rules where they appear

program (65)
    on left: 1 2
extdefs (66)
    on left: 4 6, on right: 2 6
@1 (67)
    on left: 3, on right: 4
@2 (68)
    on left: 5, on right: 6
extdef (69)
    on left: 7 8 9, on right: 4 6
datadef (70)
    on left: 10 11 12 13 14 15 16 17, on right: 8
fndef (71)
    on left: 20 21 24 25 28 29, on right: 7
@3 (72)
    on left: 18, on right: 20
@4 (73)
    on left: 19, on right: 20
@5 (74)
    on left: 22, on right: 24
@6 (75)
    on left: 23, on right: 24
@7 (76)
    on left: 26, on right: 28
@8 (77)
    on left: 27, on right: 28
identifier (78)
    on left: 30 31, on right: 81 82 165 167 169 171 173 176 197 198
    260 262
unop (79)
    on left: 32 33 34 35 36 37 38, on right: 46
expr (80)
    on left: 39, on right: 75 80 114 149 154 161 211 214 230 232 238
    241 247 249 255 267 272
exprlist (81)
    on left: 40 41, on right: 79
nonnull_exprlist (82)
    on left: 42 43, on right: 39 41 43
unary_expr (83)
    on left: 44 45 46 47 48 49 50, on right: 47 49 51
cast_expr (84)
    on left: 51 52 53, on right: 45 46 52 54
expr_no_commas (85)
    on left: 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
   , on right: 42 43 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70
    71 138 193 194 198
primary (86)
    on left: 72 73 74 75 76 78 79 80 81 82 83 84, on right: 44 79 80
    81 82 83 84
@9 (87)
    on left: 77, on right: 78
string (88)
    on left: 85 86, on right: 9 74 86 124 256 257 258 259 273 274
xdecls (89)
    on left: 87 88, on right: 20 24 28
decls (90)
    on left: 89 90 91 92, on right: 88 91 226
setspecs (91)
    on left: 93, on right: 10 11 12 20 21 24 25 28 29 94 95 186 187
decl (92)
    on left: 94 95 96 97, on right: 89 91 92
typed_declspecs (93)
    on left: 98 99, on right: 12 14 20 21 94 96 289 290 291
reserved_declspecs (94)
    on left: 100 101 102, on right: 98 99 101 102
declmods (95)
    on left: 103 104 105 106, on right: 11 13 24 25 95 97 99 105 106
    292 293
typed_typespecs (96)
    on left: 107 108, on right: 186 199
reserved_typespecquals (97)
    on left: 109 110, on right: 107 108 110
typespec (98)
    on left: 111 112 113 114 115, on right: 98 99 107 108
typespecqual_reserved (99)
    on left: 116 117 118, on right: 101 110
initdecls (100)
    on left: 119 120, on right: 12 94 120
notype_initdecls (101)
    on left: 121 122, on right: 10 11 95 122
maybeasm (102)
    on left: 123 124, on right: 126 127 129 130
initdcl (103)
    on left: 126 127, on right: 119 120 122
@10 (104)
    on left: 125, on right: 126
notype_initdcl (105)
    on left: 129 130, on right: 121
@11 (106)
    on left: 128, on right: 129
maybe_attribute (107)
    on left: 131 132, on right: 126 127 129 130 192 193
attribute_list (108)
    on left: 133 134, on right: 132 134
attrib (109)
    on left: 135 136 137, on right: 133 134
init (110)
    on left: 138 139 140 141 142, on right: 126 129 143 144
initlist (111)
    on left: 143 144, on right: 53 140 141 144
declarator (112)
    on left: 145 146, on right: 20 21 126 127 192 193
after_type_declarator (113)
    on left: 147 148 149 150 151 152, on right: 145 147 148 149 150
    151
parm_declarator (114)
    on left: 153 154 155 156 157, on right: 153 154 155 156 289
notype_declarator (115)
    on left: 158 159 160 161 162 163, on right: 24 25 28 29 129 130
    146 158 159 160 161 162 290 292
structsp (116)
    on left: 165 166 167 169 170 171 173 175 176, on right: 112 118
@12 (117)
    on left: 164, on right: 165
@13 (118)
    on left: 168, on right: 169
@14 (119)
    on left: 172, on right: 173
@15 (120)
    on left: 174, on right: 175
maybecomma (121)
    on left: 177 178, on right: 53
maybecomma_warn (122)
    on left: 179 180, on right: 173 175
component_decl_list (123)
    on left: 181 182, on right: 165 166 169 170
component_decl_list2 (124)
    on left: 183 184 185, on right: 181 182 184 185
component_decl (125)
    on left: 186 187 188, on right: 182 184
components (126)
    on left: 189 190 191, on right: 186 187 191
component_declarator (127)
    on left: 192 193 194, on right: 190 191
enumlist (128)
    on left: 195 196, on right: 173 175 196
enumerator (129)
    on left: 197 198, on right: 195 196
typename (130)
    on left: 199 200, on right: 48 50 52 53 115
absdcl (131)
    on left: 201 202, on right: 199 200 291 293
nonempty_type_quals (132)
    on left: 203 204, on right: 108 187 200 204
type_quals (133)
    on left: 205 206, on right: 151 156 160 206 208 209
absdcl1 (134)
    on left: 207 208 209 210 211 212 213 214 215, on right: 202 207
    208 210 211 212
stmts (135)
    on left: 216 217 218, on right: 217 218 220 228
xstmts (136)
    on left: 219 220, on right: 226
errstmt (137)
    on left: 221, on right: 90 92 218
pushlevel (138)
    on left: 222, on right: 226 227 228
compstmt_or_error (139)
    on left: 223 224, on right: 20 24 28
compstmt (140)
    on left: 225 226 227 228, on right: 78 223 224 231
simple_if (141)
    on left: 230, on right: 234 235
@16 (142)
    on left: 229, on right: 230
stmt (143)
    on left: 231 232 234 235 238 241 245 247 249 251 252 253 254 255
    256 257 258 259 260 262 263, on right: 216 217 230 234 238 241
    245 247 249 251 262
@17 (144)
    on left: 233, on right: 234
@18 (145)
    on left: 236, on right: 238
@19 (146)
    on left: 237, on right: 238
@20 (147)
    on left: 239, on right: 241
@21 (148)
    on left: 240, on right: 241
@22 (149)
    on left: 242, on right: 245
@23 (150)
    on left: 243, on right: 245
@24 (151)
    on left: 244, on right: 245
@25 (152)
    on left: 246, on right: 247
@26 (153)
    on left: 248, on right: 249
@27 (154)
    on left: 250, on right: 251
@28 (155)
    on left: 261, on right: 262
maybe_type_qual (156)
    on left: 264 265, on right: 256 257 258 259
xexpr (157)
    on left: 266 267, on right: 69 245
asm_operands (158)
    on left: 268 269, on right: 257 258 259
nonnull_asm_operands (159)
    on left: 270 271, on right: 269 271
asm_operand (160)
    on left: 272, on right: 270 271
asm_clobbers (161)
    on left: 273 274, on right: 259 274
parmlist (162)
    on left: 276, on right: 210 213
@29 (163)
    on left: 275, on right: 276
parmlist_or_identifiers (164)
    on left: 278, on right: 148 153 158
@30 (165)
    on left: 277, on right: 278
parmlist_or_identifiers_1 (166)
    on left: 279 280 281, on right: 278
parmlist_1 (167)
    on left: 282 283, on right: 276
parmlist_2 (168)
    on left: 284 285 286, on right: 279 282
parms (169)
    on left: 287 288, on right: 285 286 288
parm (170)
    on left: 289 290 291 292 293, on right: 287 288
identifiers (171)
    on left: 294 295, on right: 137 280 295


state 0

    $   	reduce using rule 1 (program)
    $default	reduce using rule 3 (@1)

    program	go to state 513
    extdefs	go to state 1
    @1  	go to state 2



state 1

    program  ->  extdefs .   (rule 2)
    extdefs  ->  extdefs . @2 extdef   (rule 6)

    $   	reduce using rule 2 (program)
    $default	reduce using rule 5 (@2)

    @2  	go to state 3



state 2

    extdefs  ->  @1 . extdef   (rule 4)

    error	shift, and go to state 4
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    ASM 	shift, and go to state 12
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 14

    IDENTIFIER	reduce using rule 93 (setspecs)
    '*' 	[reduce using rule 93 (setspecs)]
    '(' 	reduce using rule 93 (setspecs)

    extdef	go to state 15
    datadef	go to state 16
    fndef	go to state 17
    setspecs	go to state 18
    typed_declspecs	go to state 19
    declmods	go to state 20
    typespec	go to state 21
    structsp	go to state 22



state 3

    extdefs  ->  extdefs @2 . extdef   (rule 6)

    error	shift, and go to state 4
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    ASM 	shift, and go to state 12
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 14

    IDENTIFIER	reduce using rule 93 (setspecs)
    '*' 	[reduce using rule 93 (setspecs)]
    '(' 	reduce using rule 93 (setspecs)

    extdef	go to state 23
    datadef	go to state 16
    fndef	go to state 17
    setspecs	go to state 18
    typed_declspecs	go to state 19
    declmods	go to state 20
    typespec	go to state 21
    structsp	go to state 22



state 4

    datadef  ->  error . ';'   (rule 15)
    datadef  ->  error . '}'   (rule 16)

    ';' 	shift, and go to state 24
    '}' 	shift, and go to state 25



state 5

    typespec  ->  TYPENAME .   (rule 113)

    $default	reduce using rule 113 (typespec)



state 6

    declmods  ->  SCSPEC .   (rule 104)

    $default	reduce using rule 104 (declmods)



state 7

    typespec  ->  TYPESPEC .   (rule 111)

    $default	reduce using rule 111 (typespec)



state 8

    declmods  ->  TYPE_QUAL .   (rule 103)

    $default	reduce using rule 103 (declmods)



state 9

    structsp  ->  ENUM . identifier '{' @14 enumlist maybecomma_warn '}'   (rule 173)
    structsp  ->  ENUM . '{' @15 enumlist maybecomma_warn '}'   (rule 175)
    structsp  ->  ENUM . identifier   (rule 176)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27
    '{' 	shift, and go to state 28

    identifier	go to state 29



state 10

    structsp  ->  STRUCT . identifier '{' @12 component_decl_list '}'   (rule 165)
    structsp  ->  STRUCT . '{' component_decl_list '}'   (rule 166)
    structsp  ->  STRUCT . identifier   (rule 167)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27
    '{' 	shift, and go to state 30

    identifier	go to state 31



state 11

    structsp  ->  UNION . identifier '{' @13 component_decl_list '}'   (rule 169)
    structsp  ->  UNION . '{' component_decl_list '}'   (rule 170)
    structsp  ->  UNION . identifier   (rule 171)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27
    '{' 	shift, and go to state 32

    identifier	go to state 33



state 12

    extdef  ->  ASM . '(' string ')' ';'   (rule 9)

    '(' 	shift, and go to state 34



state 13

    typespec  ->  TYPEOF . '(' expr ')'   (rule 114)
    typespec  ->  TYPEOF . '(' typename ')'   (rule 115)

    '(' 	shift, and go to state 35



state 14

    datadef  ->  ';' .   (rule 17)

    $default	reduce using rule 17 (datadef)



state 15

    extdefs  ->  @1 extdef .   (rule 4)

    $default	reduce using rule 4 (extdefs)



state 16

    extdef  ->  datadef .   (rule 8)

    $default	reduce using rule 8 (extdef)



state 17

    extdef  ->  fndef .   (rule 7)

    $default	reduce using rule 7 (extdef)



state 18

    datadef  ->  setspecs . notype_initdecls ';'   (rule 10)
    fndef  ->  setspecs . notype_declarator @7 xdecls @8 compstmt_or_error   (rule 28)
    fndef  ->  setspecs . notype_declarator error   (rule 29)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_initdecls	go to state 39
    notype_initdcl	go to state 40
    notype_declarator	go to state 41



state 19

    datadef  ->  typed_declspecs . setspecs initdecls ';'   (rule 12)
    datadef  ->  typed_declspecs . ';'   (rule 14)
    fndef  ->  typed_declspecs . setspecs declarator @3 xdecls @4 compstmt_or_error   (rule 20)
    fndef  ->  typed_declspecs . setspecs declarator error   (rule 21)

    ';' 	shift, and go to state 42

    $default	reduce using rule 93 (setspecs)

    setspecs	go to state 43



state 20

    datadef  ->  declmods . setspecs notype_initdecls ';'   (rule 11)
    datadef  ->  declmods . ';'   (rule 13)
    fndef  ->  declmods . setspecs notype_declarator @5 xdecls @6 compstmt_or_error   (rule 24)
    fndef  ->  declmods . setspecs notype_declarator error   (rule 25)
    typed_declspecs  ->  declmods . typespec reserved_declspecs   (rule 99)
    declmods  ->  declmods . TYPE_QUAL   (rule 105)
    declmods  ->  declmods . SCSPEC   (rule 106)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 44
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 45
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 46

    $default	reduce using rule 93 (setspecs)

    setspecs	go to state 47
    typespec	go to state 48
    structsp	go to state 22



state 21

    typed_declspecs  ->  typespec . reserved_declspecs   (rule 98)

    $default	reduce using rule 100 (reserved_declspecs)

    reserved_declspecs	go to state 49



state 22

    typespec  ->  structsp .   (rule 112)

    $default	reduce using rule 112 (typespec)



state 23

    extdefs  ->  extdefs @2 extdef .   (rule 6)

    $default	reduce using rule 6 (extdefs)



state 24

    datadef  ->  error ';' .   (rule 15)

    $default	reduce using rule 15 (datadef)



state 25

    datadef  ->  error '}' .   (rule 16)

    $default	reduce using rule 16 (datadef)



state 26

    identifier  ->  IDENTIFIER .   (rule 30)

    $default	reduce using rule 30 (identifier)



state 27

    identifier  ->  TYPENAME .   (rule 31)

    $default	reduce using rule 31 (identifier)



state 28

    structsp  ->  ENUM '{' . @15 enumlist maybecomma_warn '}'   (rule 175)

    $default	reduce using rule 174 (@15)

    @15 	go to state 50



state 29

    structsp  ->  ENUM identifier . '{' @14 enumlist maybecomma_warn '}'   (rule 173)
    structsp  ->  ENUM identifier .   (rule 176)

    '{' 	shift, and go to state 51

    $default	reduce using rule 176 (structsp)



state 30

    structsp  ->  STRUCT '{' . component_decl_list '}'   (rule 166)

    $default	reduce using rule 183 (component_decl_list2)

    component_decl_list	go to state 52
    component_decl_list2	go to state 53



state 31

    structsp  ->  STRUCT identifier . '{' @12 component_decl_list '}'   (rule 165)
    structsp  ->  STRUCT identifier .   (rule 167)

    '{' 	shift, and go to state 54

    $default	reduce using rule 167 (structsp)



state 32

    structsp  ->  UNION '{' . component_decl_list '}'   (rule 170)

    $default	reduce using rule 183 (component_decl_list2)

    component_decl_list	go to state 55
    component_decl_list2	go to state 53



state 33

    structsp  ->  UNION identifier . '{' @13 component_decl_list '}'   (rule 169)
    structsp  ->  UNION identifier .   (rule 171)

    '{' 	shift, and go to state 56

    $default	reduce using rule 171 (structsp)



state 34

    extdef  ->  ASM '(' . string ')' ';'   (rule 9)

    STRING	shift, and go to state 57

    string	go to state 58



state 35

    typespec  ->  TYPEOF '(' . expr ')'   (rule 114)
    typespec  ->  TYPEOF '(' . typename ')'   (rule 115)

    IDENTIFIER	shift, and go to state 59
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 60
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 74
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    typed_typespecs	go to state 81
    typespec	go to state 82
    structsp	go to state 22
    typename	go to state 83
    nonempty_type_quals	go to state 84



state 36

    notype_declarator  ->  IDENTIFIER .   (rule 163)

    $default	reduce using rule 163 (notype_declarator)



state 37

    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 160)

    $default	reduce using rule 205 (type_quals)

    type_quals	go to state 85



state 38

    notype_declarator  ->  '(' . notype_declarator ')'   (rule 159)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_declarator	go to state 86



state 39

    datadef  ->  setspecs notype_initdecls . ';'   (rule 10)
    notype_initdecls  ->  notype_initdecls . ',' initdcl   (rule 122)

    ';' 	shift, and go to state 87
    ',' 	shift, and go to state 88



state 40

    notype_initdecls  ->  notype_initdcl .   (rule 121)

    $default	reduce using rule 121 (notype_initdecls)



state 41

    fndef  ->  setspecs notype_declarator . @7 xdecls @8 compstmt_or_error   (rule 28)
    fndef  ->  setspecs notype_declarator . error   (rule 29)
    notype_initdcl  ->  notype_declarator . maybeasm maybe_attribute '=' @11 init   (rule 129)
    notype_initdcl  ->  notype_declarator . maybeasm maybe_attribute   (rule 130)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)

    error	shift, and go to state 89
    ASM 	shift, and go to state 90
    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    error	[reduce using rule 26 (@7)]
    TYPENAME	reduce using rule 26 (@7)
    SCSPEC	reduce using rule 26 (@7)
    TYPESPEC	reduce using rule 26 (@7)
    TYPE_QUAL	reduce using rule 26 (@7)
    ENUM	reduce using rule 26 (@7)
    STRUCT	reduce using rule 26 (@7)
    UNION	reduce using rule 26 (@7)
    TYPEOF	reduce using rule 26 (@7)
    ATTRIBUTE	reduce using rule 123 (maybeasm)
    '=' 	reduce using rule 123 (maybeasm)
    ';' 	reduce using rule 123 (maybeasm)
    ',' 	reduce using rule 123 (maybeasm)
    '{' 	reduce using rule 26 (@7)

    @7  	go to state 93
    maybeasm	go to state 94



state 42

    datadef  ->  typed_declspecs ';' .   (rule 14)

    $default	reduce using rule 14 (datadef)



state 43

    datadef  ->  typed_declspecs setspecs . initdecls ';'   (rule 12)
    fndef  ->  typed_declspecs setspecs . declarator @3 xdecls @4 compstmt_or_error   (rule 20)
    fndef  ->  typed_declspecs setspecs . declarator error   (rule 21)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    initdecls	go to state 98
    initdcl	go to state 99
    declarator	go to state 100
    after_type_declarator	go to state 101
    notype_declarator	go to state 102



state 44

    declmods  ->  declmods SCSPEC .   (rule 106)

    $default	reduce using rule 106 (declmods)



state 45

    declmods  ->  declmods TYPE_QUAL .   (rule 105)

    $default	reduce using rule 105 (declmods)



state 46

    datadef  ->  declmods ';' .   (rule 13)

    $default	reduce using rule 13 (datadef)



state 47

    datadef  ->  declmods setspecs . notype_initdecls ';'   (rule 11)
    fndef  ->  declmods setspecs . notype_declarator @5 xdecls @6 compstmt_or_error   (rule 24)
    fndef  ->  declmods setspecs . notype_declarator error   (rule 25)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_initdecls	go to state 103
    notype_initdcl	go to state 40
    notype_declarator	go to state 104



state 48

    typed_declspecs  ->  declmods typespec . reserved_declspecs   (rule 99)

    $default	reduce using rule 100 (reserved_declspecs)

    reserved_declspecs	go to state 105



state 49

    typed_declspecs  ->  typespec reserved_declspecs .   (rule 98)
    reserved_declspecs  ->  reserved_declspecs . typespecqual_reserved   (rule 101)
    reserved_declspecs  ->  reserved_declspecs . SCSPEC   (rule 102)

    SCSPEC	shift, and go to state 106
    TYPESPEC	shift, and go to state 107
    TYPE_QUAL	shift, and go to state 108
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 98 (typed_declspecs)

    typespecqual_reserved	go to state 109
    structsp	go to state 110



state 50

    structsp  ->  ENUM '{' @15 . enumlist maybecomma_warn '}'   (rule 175)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 111
    enumlist	go to state 112
    enumerator	go to state 113



state 51

    structsp  ->  ENUM identifier '{' . @14 enumlist maybecomma_warn '}'   (rule 173)

    $default	reduce using rule 172 (@14)

    @14 	go to state 114



state 52

    structsp  ->  STRUCT '{' component_decl_list . '}'   (rule 166)

    '}' 	shift, and go to state 115



state 53

    component_decl_list  ->  component_decl_list2 .   (rule 181)
    component_decl_list  ->  component_decl_list2 . component_decl   (rule 182)
    component_decl_list2  ->  component_decl_list2 . component_decl ';'   (rule 184)
    component_decl_list2  ->  component_decl_list2 . ';'   (rule 185)

    error	shift, and go to state 116
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 60
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 117

    '}' 	reduce using rule 181 (component_decl_list)

    typed_typespecs	go to state 118
    typespec	go to state 82
    structsp	go to state 22
    component_decl	go to state 119
    nonempty_type_quals	go to state 120



state 54

    structsp  ->  STRUCT identifier '{' . @12 component_decl_list '}'   (rule 165)

    $default	reduce using rule 164 (@12)

    @12 	go to state 121



state 55

    structsp  ->  UNION '{' component_decl_list . '}'   (rule 170)

    '}' 	shift, and go to state 122



state 56

    structsp  ->  UNION identifier '{' . @13 component_decl_list '}'   (rule 169)

    $default	reduce using rule 168 (@13)

    @13 	go to state 123



state 57

    string  ->  STRING .   (rule 85)

    $default	reduce using rule 85 (string)



state 58

    extdef  ->  ASM '(' string . ')' ';'   (rule 9)
    string  ->  string . STRING   (rule 86)

    STRING	shift, and go to state 124
    ')' 	shift, and go to state 125



state 59

    primary  ->  IDENTIFIER .   (rule 72)

    $default	reduce using rule 72 (primary)



state 60

    nonempty_type_quals  ->  TYPE_QUAL .   (rule 203)

    $default	reduce using rule 203 (nonempty_type_quals)



state 61

    primary  ->  CONSTANT .   (rule 73)

    $default	reduce using rule 73 (primary)



state 62

    unary_expr  ->  SIZEOF . unary_expr   (rule 47)
    unary_expr  ->  SIZEOF . '(' typename ')'   (rule 48)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 126
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 127
    primary	go to state 79
    string	go to state 80



state 63

    unary_expr  ->  ALIGNOF . unary_expr   (rule 49)
    unary_expr  ->  ALIGNOF . '(' typename ')'   (rule 50)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 128
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 129
    primary	go to state 79
    string	go to state 80



state 64

    unop  ->  '&' .   (rule 32)

    $default	reduce using rule 32 (unop)



state 65

    unop  ->  '+' .   (rule 34)

    $default	reduce using rule 34 (unop)



state 66

    unop  ->  '-' .   (rule 33)

    $default	reduce using rule 33 (unop)



state 67

    unary_expr  ->  '*' . cast_expr   (rule 45)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 130
    primary	go to state 79
    string	go to state 80



state 68

    unop  ->  PLUSPLUS .   (rule 35)

    $default	reduce using rule 35 (unop)



state 69

    unop  ->  MINUSMINUS .   (rule 36)

    $default	reduce using rule 36 (unop)



state 70

    cast_expr  ->  '(' . typename ')' cast_expr   (rule 52)
    cast_expr  ->  '(' . typename ')' '{' initlist maybecomma '}'   (rule 53)
    primary  ->  '(' . expr ')'   (rule 75)
    primary  ->  '(' . error ')'   (rule 76)
    primary  ->  '(' . @9 compstmt ')'   (rule 78)

    error	shift, and go to state 131
    IDENTIFIER	shift, and go to state 59
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 60
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    '{' 	reduce using rule 77 (@9)

    unop	go to state 73
    expr	go to state 132
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    @9  	go to state 133
    string	go to state 80
    typed_typespecs	go to state 81
    typespec	go to state 82
    structsp	go to state 22
    typename	go to state 134
    nonempty_type_quals	go to state 84



state 71

    unop  ->  '~' .   (rule 37)

    $default	reduce using rule 37 (unop)



state 72

    unop  ->  '!' .   (rule 38)

    $default	reduce using rule 38 (unop)



state 73

    unary_expr  ->  unop . cast_expr   (rule 46)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 135
    primary	go to state 79
    string	go to state 80



state 74

    typespec  ->  TYPEOF '(' expr . ')'   (rule 114)

    ')' 	shift, and go to state 136



state 75

    expr  ->  nonnull_exprlist .   (rule 39)
    nonnull_exprlist  ->  nonnull_exprlist . ',' expr_no_commas   (rule 43)

    ',' 	shift, and go to state 137

    $default	reduce using rule 39 (expr)



state 76

    cast_expr  ->  unary_expr .   (rule 51)

    $default	reduce using rule 51 (cast_expr)



state 77

    expr_no_commas  ->  cast_expr .   (rule 54)

    $default	reduce using rule 54 (expr_no_commas)



state 78

    nonnull_exprlist  ->  expr_no_commas .   (rule 42)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 42 (nonnull_exprlist)



state 79

    unary_expr  ->  primary .   (rule 44)
    primary  ->  primary . '(' exprlist ')'   (rule 79)
    primary  ->  primary . '[' expr ']'   (rule 80)
    primary  ->  primary . '.' identifier   (rule 81)
    primary  ->  primary . POINTSAT identifier   (rule 82)
    primary  ->  primary . PLUSPLUS   (rule 83)
    primary  ->  primary . MINUSMINUS   (rule 84)

    PLUSPLUS	shift, and go to state 155
    MINUSMINUS	shift, and go to state 156
    POINTSAT	shift, and go to state 157
    '.' 	shift, and go to state 158
    '(' 	shift, and go to state 159
    '[' 	shift, and go to state 160

    $default	reduce using rule 44 (unary_expr)



state 80

    primary  ->  string .   (rule 74)
    string  ->  string . STRING   (rule 86)

    STRING	shift, and go to state 124

    $default	reduce using rule 74 (primary)



state 81

    typename  ->  typed_typespecs . absdcl   (rule 199)

    '*' 	shift, and go to state 161
    '(' 	shift, and go to state 162
    '[' 	shift, and go to state 163

    $default	reduce using rule 201 (absdcl)

    absdcl	go to state 164
    absdcl1	go to state 165



state 82

    typed_typespecs  ->  typespec . reserved_typespecquals   (rule 107)

    $default	reduce using rule 109 (reserved_typespecquals)

    reserved_typespecquals	go to state 166



state 83

    typespec  ->  TYPEOF '(' typename . ')'   (rule 115)

    ')' 	shift, and go to state 167



state 84

    typed_typespecs  ->  nonempty_type_quals . typespec reserved_typespecquals   (rule 108)
    typename  ->  nonempty_type_quals . absdcl   (rule 200)
    nonempty_type_quals  ->  nonempty_type_quals . TYPE_QUAL   (rule 204)

    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 168
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    '*' 	shift, and go to state 161
    '(' 	shift, and go to state 162
    '[' 	shift, and go to state 163

    $default	reduce using rule 201 (absdcl)

    typespec	go to state 169
    structsp	go to state 22
    absdcl	go to state 170
    absdcl1	go to state 165



state 85

    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 160)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 206)

    IDENTIFIER	shift, and go to state 36
    TYPE_QUAL	shift, and go to state 171
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_declarator	go to state 172



state 86

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  '(' notype_declarator . ')'   (rule 159)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)

    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92
    ')' 	shift, and go to state 173



state 87

    datadef  ->  setspecs notype_initdecls ';' .   (rule 10)

    $default	reduce using rule 10 (datadef)



state 88

    notype_initdecls  ->  notype_initdecls ',' . initdcl   (rule 122)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    initdcl	go to state 174
    declarator	go to state 175
    after_type_declarator	go to state 101
    notype_declarator	go to state 102



state 89

    fndef  ->  setspecs notype_declarator error .   (rule 29)

    $default	reduce using rule 29 (fndef)



state 90

    maybeasm  ->  ASM . '(' string ')'   (rule 124)

    '(' 	shift, and go to state 176



state 91

    notype_declarator  ->  notype_declarator '(' . parmlist_or_identifiers   (rule 158)

    $default	reduce using rule 277 (@30)

    parmlist_or_identifiers	go to state 177
    @30 	go to state 178



state 92

    notype_declarator  ->  notype_declarator '[' . expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator '[' . ']'   (rule 162)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    ']' 	shift, and go to state 179

    unop	go to state 73
    expr	go to state 180
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 93

    fndef  ->  setspecs notype_declarator @7 . xdecls @8 compstmt_or_error   (rule 28)

    error	shift, and go to state 181
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    error	[reduce using rule 87 (xdecls)]
    '{' 	reduce using rule 87 (xdecls)

    xdecls	go to state 182
    decls	go to state 183
    decl	go to state 184
    typed_declspecs	go to state 185
    declmods	go to state 186
    typespec	go to state 21
    structsp	go to state 22
    errstmt	go to state 187



state 94

    notype_initdcl  ->  notype_declarator maybeasm . maybe_attribute '=' @11 init   (rule 129)
    notype_initdcl  ->  notype_declarator maybeasm . maybe_attribute   (rule 130)

    ATTRIBUTE	shift, and go to state 188

    $default	reduce using rule 131 (maybe_attribute)

    maybe_attribute	go to state 189



state 95

    after_type_declarator  ->  TYPENAME .   (rule 152)

    $default	reduce using rule 152 (after_type_declarator)



state 96

    after_type_declarator  ->  '*' . type_quals after_type_declarator   (rule 151)
    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 160)

    $default	reduce using rule 205 (type_quals)

    type_quals	go to state 190



state 97

    after_type_declarator  ->  '(' . after_type_declarator ')'   (rule 147)
    notype_declarator  ->  '(' . notype_declarator ')'   (rule 159)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    after_type_declarator	go to state 191
    notype_declarator	go to state 86



state 98

    datadef  ->  typed_declspecs setspecs initdecls . ';'   (rule 12)
    initdecls  ->  initdecls . ',' initdcl   (rule 120)

    ';' 	shift, and go to state 192
    ',' 	shift, and go to state 193



state 99

    initdecls  ->  initdcl .   (rule 119)

    $default	reduce using rule 119 (initdecls)



state 100

    fndef  ->  typed_declspecs setspecs declarator . @3 xdecls @4 compstmt_or_error   (rule 20)
    fndef  ->  typed_declspecs setspecs declarator . error   (rule 21)
    initdcl  ->  declarator . maybeasm maybe_attribute '=' @10 init   (rule 126)
    initdcl  ->  declarator . maybeasm maybe_attribute   (rule 127)

    error	shift, and go to state 194
    ASM 	shift, and go to state 90

    error	[reduce using rule 18 (@3)]
    TYPENAME	reduce using rule 18 (@3)
    SCSPEC	reduce using rule 18 (@3)
    TYPESPEC	reduce using rule 18 (@3)
    TYPE_QUAL	reduce using rule 18 (@3)
    ENUM	reduce using rule 18 (@3)
    STRUCT	reduce using rule 18 (@3)
    UNION	reduce using rule 18 (@3)
    TYPEOF	reduce using rule 18 (@3)
    ATTRIBUTE	reduce using rule 123 (maybeasm)
    '=' 	reduce using rule 123 (maybeasm)
    ';' 	reduce using rule 123 (maybeasm)
    ',' 	reduce using rule 123 (maybeasm)
    '{' 	reduce using rule 18 (@3)

    @3  	go to state 195
    maybeasm	go to state 196



state 101

    declarator  ->  after_type_declarator .   (rule 145)
    after_type_declarator  ->  after_type_declarator . '(' parmlist_or_identifiers   (rule 148)
    after_type_declarator  ->  after_type_declarator . '[' expr ']'   (rule 149)
    after_type_declarator  ->  after_type_declarator . '[' ']'   (rule 150)

    '(' 	shift, and go to state 197
    '[' 	shift, and go to state 198

    $default	reduce using rule 145 (declarator)



state 102

    declarator  ->  notype_declarator .   (rule 146)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)

    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    $default	reduce using rule 146 (declarator)



state 103

    datadef  ->  declmods setspecs notype_initdecls . ';'   (rule 11)
    notype_initdecls  ->  notype_initdecls . ',' initdcl   (rule 122)

    ';' 	shift, and go to state 199
    ',' 	shift, and go to state 88



state 104

    fndef  ->  declmods setspecs notype_declarator . @5 xdecls @6 compstmt_or_error   (rule 24)
    fndef  ->  declmods setspecs notype_declarator . error   (rule 25)
    notype_initdcl  ->  notype_declarator . maybeasm maybe_attribute '=' @11 init   (rule 129)
    notype_initdcl  ->  notype_declarator . maybeasm maybe_attribute   (rule 130)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)

    error	shift, and go to state 200
    ASM 	shift, and go to state 90
    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    error	[reduce using rule 22 (@5)]
    TYPENAME	reduce using rule 22 (@5)
    SCSPEC	reduce using rule 22 (@5)
    TYPESPEC	reduce using rule 22 (@5)
    TYPE_QUAL	reduce using rule 22 (@5)
    ENUM	reduce using rule 22 (@5)
    STRUCT	reduce using rule 22 (@5)
    UNION	reduce using rule 22 (@5)
    TYPEOF	reduce using rule 22 (@5)
    ATTRIBUTE	reduce using rule 123 (maybeasm)
    '=' 	reduce using rule 123 (maybeasm)
    ';' 	reduce using rule 123 (maybeasm)
    ',' 	reduce using rule 123 (maybeasm)
    '{' 	reduce using rule 22 (@5)

    @5  	go to state 201
    maybeasm	go to state 94



state 105

    typed_declspecs  ->  declmods typespec reserved_declspecs .   (rule 99)
    reserved_declspecs  ->  reserved_declspecs . typespecqual_reserved   (rule 101)
    reserved_declspecs  ->  reserved_declspecs . SCSPEC   (rule 102)

    SCSPEC	shift, and go to state 106
    TYPESPEC	shift, and go to state 107
    TYPE_QUAL	shift, and go to state 108
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 99 (typed_declspecs)

    typespecqual_reserved	go to state 109
    structsp	go to state 110



state 106

    reserved_declspecs  ->  reserved_declspecs SCSPEC .   (rule 102)

    $default	reduce using rule 102 (reserved_declspecs)



state 107

    typespecqual_reserved  ->  TYPESPEC .   (rule 116)

    $default	reduce using rule 116 (typespecqual_reserved)



state 108

    typespecqual_reserved  ->  TYPE_QUAL .   (rule 117)

    $default	reduce using rule 117 (typespecqual_reserved)



state 109

    reserved_declspecs  ->  reserved_declspecs typespecqual_reserved .   (rule 101)

    $default	reduce using rule 101 (reserved_declspecs)



state 110

    typespecqual_reserved  ->  structsp .   (rule 118)

    $default	reduce using rule 118 (typespecqual_reserved)



state 111

    enumerator  ->  identifier .   (rule 197)
    enumerator  ->  identifier . '=' expr_no_commas   (rule 198)

    '=' 	shift, and go to state 202

    $default	reduce using rule 197 (enumerator)



state 112

    structsp  ->  ENUM '{' @15 enumlist . maybecomma_warn '}'   (rule 175)
    enumlist  ->  enumlist . ',' enumerator   (rule 196)

    ',' 	shift, and go to state 203

    $default	reduce using rule 179 (maybecomma_warn)

    maybecomma_warn	go to state 204



state 113

    enumlist  ->  enumerator .   (rule 195)

    $default	reduce using rule 195 (enumlist)



state 114

    structsp  ->  ENUM identifier '{' @14 . enumlist maybecomma_warn '}'   (rule 173)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 111
    enumlist	go to state 205
    enumerator	go to state 113



state 115

    structsp  ->  STRUCT '{' component_decl_list '}' .   (rule 166)

    $default	reduce using rule 166 (structsp)



state 116

    component_decl  ->  error .   (rule 188)

    $default	reduce using rule 188 (component_decl)



state 117

    component_decl_list2  ->  component_decl_list2 ';' .   (rule 185)

    $default	reduce using rule 185 (component_decl_list2)



state 118

    component_decl  ->  typed_typespecs . setspecs components   (rule 186)

    $default	reduce using rule 93 (setspecs)

    setspecs	go to state 206



state 119

    component_decl_list  ->  component_decl_list2 component_decl .   (rule 182)
    component_decl_list2  ->  component_decl_list2 component_decl . ';'   (rule 184)

    ';' 	shift, and go to state 207

    $default	reduce using rule 182 (component_decl_list)



state 120

    typed_typespecs  ->  nonempty_type_quals . typespec reserved_typespecquals   (rule 108)
    component_decl  ->  nonempty_type_quals . setspecs components   (rule 187)
    nonempty_type_quals  ->  nonempty_type_quals . TYPE_QUAL   (rule 204)

    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 168
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    TYPENAME	[reduce using rule 93 (setspecs)]
    $default	reduce using rule 93 (setspecs)

    setspecs	go to state 208
    typespec	go to state 169
    structsp	go to state 22



state 121

    structsp  ->  STRUCT identifier '{' @12 . component_decl_list '}'   (rule 165)

    $default	reduce using rule 183 (component_decl_list2)

    component_decl_list	go to state 209
    component_decl_list2	go to state 53



state 122

    structsp  ->  UNION '{' component_decl_list '}' .   (rule 170)

    $default	reduce using rule 170 (structsp)



state 123

    structsp  ->  UNION identifier '{' @13 . component_decl_list '}'   (rule 169)

    $default	reduce using rule 183 (component_decl_list2)

    component_decl_list	go to state 210
    component_decl_list2	go to state 53



state 124

    string  ->  string STRING .   (rule 86)

    $default	reduce using rule 86 (string)



state 125

    extdef  ->  ASM '(' string ')' . ';'   (rule 9)

    ';' 	shift, and go to state 211



state 126

    unary_expr  ->  SIZEOF '(' . typename ')'   (rule 48)
    primary  ->  '(' . expr ')'   (rule 75)
    primary  ->  '(' . error ')'   (rule 76)
    primary  ->  '(' . @9 compstmt ')'   (rule 78)

    error	shift, and go to state 131
    IDENTIFIER	shift, and go to state 59
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 60
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    '{' 	reduce using rule 77 (@9)

    unop	go to state 73
    expr	go to state 132
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    @9  	go to state 133
    string	go to state 80
    typed_typespecs	go to state 81
    typespec	go to state 82
    structsp	go to state 22
    typename	go to state 212
    nonempty_type_quals	go to state 84



state 127

    unary_expr  ->  SIZEOF unary_expr .   (rule 47)

    $default	reduce using rule 47 (unary_expr)



state 128

    unary_expr  ->  ALIGNOF '(' . typename ')'   (rule 50)
    primary  ->  '(' . expr ')'   (rule 75)
    primary  ->  '(' . error ')'   (rule 76)
    primary  ->  '(' . @9 compstmt ')'   (rule 78)

    error	shift, and go to state 131
    IDENTIFIER	shift, and go to state 59
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 60
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    '{' 	reduce using rule 77 (@9)

    unop	go to state 73
    expr	go to state 132
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    @9  	go to state 133
    string	go to state 80
    typed_typespecs	go to state 81
    typespec	go to state 82
    structsp	go to state 22
    typename	go to state 213
    nonempty_type_quals	go to state 84



state 129

    unary_expr  ->  ALIGNOF unary_expr .   (rule 49)

    $default	reduce using rule 49 (unary_expr)



state 130

    unary_expr  ->  '*' cast_expr .   (rule 45)

    $default	reduce using rule 45 (unary_expr)



state 131

    primary  ->  '(' error . ')'   (rule 76)

    ')' 	shift, and go to state 214



state 132

    primary  ->  '(' expr . ')'   (rule 75)

    ')' 	shift, and go to state 215



state 133

    primary  ->  '(' @9 . compstmt ')'   (rule 78)

    '{' 	shift, and go to state 216

    compstmt	go to state 217



state 134

    cast_expr  ->  '(' typename . ')' cast_expr   (rule 52)
    cast_expr  ->  '(' typename . ')' '{' initlist maybecomma '}'   (rule 53)

    ')' 	shift, and go to state 218



state 135

    unary_expr  ->  unop cast_expr .   (rule 46)

    $default	reduce using rule 46 (unary_expr)



state 136

    typespec  ->  TYPEOF '(' expr ')' .   (rule 114)

    $default	reduce using rule 114 (typespec)



state 137

    nonnull_exprlist  ->  nonnull_exprlist ',' . expr_no_commas   (rule 43)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 219
    primary	go to state 79
    string	go to state 80



state 138

    expr_no_commas  ->  expr_no_commas ASSIGN . expr_no_commas   (rule 71)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 220
    primary	go to state 79
    string	go to state 80



state 139

    expr_no_commas  ->  expr_no_commas '=' . expr_no_commas   (rule 70)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 221
    primary	go to state 79
    string	go to state 80



state 140

    expr_no_commas  ->  expr_no_commas '?' . xexpr ':' expr_no_commas   (rule 69)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    $default	reduce using rule 266 (xexpr)

    unop	go to state 73
    expr	go to state 222
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    xexpr	go to state 223



state 141

    expr_no_commas  ->  expr_no_commas OROR . expr_no_commas   (rule 68)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 224
    primary	go to state 79
    string	go to state 80



state 142

    expr_no_commas  ->  expr_no_commas ANDAND . expr_no_commas   (rule 67)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 225
    primary	go to state 79
    string	go to state 80



state 143

    expr_no_commas  ->  expr_no_commas '|' . expr_no_commas   (rule 65)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 226
    primary	go to state 79
    string	go to state 80



state 144

    expr_no_commas  ->  expr_no_commas '^' . expr_no_commas   (rule 66)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 227
    primary	go to state 79
    string	go to state 80



state 145

    expr_no_commas  ->  expr_no_commas '&' . expr_no_commas   (rule 64)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 228
    primary	go to state 79
    string	go to state 80



state 146

    expr_no_commas  ->  expr_no_commas EQCOMPARE . expr_no_commas   (rule 63)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 229
    primary	go to state 79
    string	go to state 80



state 147

    expr_no_commas  ->  expr_no_commas ARITHCOMPARE . expr_no_commas   (rule 62)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 230
    primary	go to state 79
    string	go to state 80



state 148

    expr_no_commas  ->  expr_no_commas LSHIFT . expr_no_commas   (rule 60)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 231
    primary	go to state 79
    string	go to state 80



state 149

    expr_no_commas  ->  expr_no_commas RSHIFT . expr_no_commas   (rule 61)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 232
    primary	go to state 79
    string	go to state 80



state 150

    expr_no_commas  ->  expr_no_commas '+' . expr_no_commas   (rule 55)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 233
    primary	go to state 79
    string	go to state 80



state 151

    expr_no_commas  ->  expr_no_commas '-' . expr_no_commas   (rule 56)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 234
    primary	go to state 79
    string	go to state 80



state 152

    expr_no_commas  ->  expr_no_commas '*' . expr_no_commas   (rule 57)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 235
    primary	go to state 79
    string	go to state 80



state 153

    expr_no_commas  ->  expr_no_commas '/' . expr_no_commas   (rule 58)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 236
    primary	go to state 79
    string	go to state 80



state 154

    expr_no_commas  ->  expr_no_commas '%' . expr_no_commas   (rule 59)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 237
    primary	go to state 79
    string	go to state 80



state 155

    primary  ->  primary PLUSPLUS .   (rule 83)

    $default	reduce using rule 83 (primary)



state 156

    primary  ->  primary MINUSMINUS .   (rule 84)

    $default	reduce using rule 84 (primary)



state 157

    primary  ->  primary POINTSAT . identifier   (rule 82)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 238



state 158

    primary  ->  primary '.' . identifier   (rule 81)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 239



state 159

    primary  ->  primary '(' . exprlist ')'   (rule 79)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    $default	reduce using rule 40 (exprlist)

    unop	go to state 73
    exprlist	go to state 240
    nonnull_exprlist	go to state 241
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 160

    primary  ->  primary '[' . expr ']'   (rule 80)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 242
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 161

    absdcl1  ->  '*' . type_quals absdcl1   (rule 208)
    absdcl1  ->  '*' . type_quals   (rule 209)

    $default	reduce using rule 205 (type_quals)

    type_quals	go to state 243



state 162

    absdcl1  ->  '(' . absdcl1 ')'   (rule 207)
    absdcl1  ->  '(' . parmlist   (rule 213)

    '*' 	shift, and go to state 161
    '(' 	shift, and go to state 162
    '[' 	shift, and go to state 163

    $default	reduce using rule 275 (@29)

    absdcl1	go to state 244
    parmlist	go to state 245
    @29 	go to state 246



state 163

    absdcl1  ->  '[' . expr ']'   (rule 214)
    absdcl1  ->  '[' . ']'   (rule 215)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    ']' 	shift, and go to state 247

    unop	go to state 73
    expr	go to state 248
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 164

    typename  ->  typed_typespecs absdcl .   (rule 199)

    $default	reduce using rule 199 (typename)



state 165

    absdcl  ->  absdcl1 .   (rule 202)
    absdcl1  ->  absdcl1 . '(' parmlist   (rule 210)
    absdcl1  ->  absdcl1 . '[' expr ']'   (rule 211)
    absdcl1  ->  absdcl1 . '[' ']'   (rule 212)

    '(' 	shift, and go to state 249
    '[' 	shift, and go to state 250

    $default	reduce using rule 202 (absdcl)



state 166

    typed_typespecs  ->  typespec reserved_typespecquals .   (rule 107)
    reserved_typespecquals  ->  reserved_typespecquals . typespecqual_reserved   (rule 110)

    TYPESPEC	shift, and go to state 107
    TYPE_QUAL	shift, and go to state 108
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 107 (typed_typespecs)

    typespecqual_reserved	go to state 251
    structsp	go to state 110



state 167

    typespec  ->  TYPEOF '(' typename ')' .   (rule 115)

    $default	reduce using rule 115 (typespec)



state 168

    nonempty_type_quals  ->  nonempty_type_quals TYPE_QUAL .   (rule 204)

    $default	reduce using rule 204 (nonempty_type_quals)



state 169

    typed_typespecs  ->  nonempty_type_quals typespec . reserved_typespecquals   (rule 108)

    $default	reduce using rule 109 (reserved_typespecquals)

    reserved_typespecquals	go to state 252



state 170

    typename  ->  nonempty_type_quals absdcl .   (rule 200)

    $default	reduce using rule 200 (typename)



state 171

    type_quals  ->  type_quals TYPE_QUAL .   (rule 206)

    $default	reduce using rule 206 (type_quals)



state 172

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  '*' type_quals notype_declarator .   (rule 160)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)

    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    $default	reduce using rule 160 (notype_declarator)



state 173

    notype_declarator  ->  '(' notype_declarator ')' .   (rule 159)

    $default	reduce using rule 159 (notype_declarator)



state 174

    notype_initdecls  ->  notype_initdecls ',' initdcl .   (rule 122)

    $default	reduce using rule 122 (notype_initdecls)



state 175

    initdcl  ->  declarator . maybeasm maybe_attribute '=' @10 init   (rule 126)
    initdcl  ->  declarator . maybeasm maybe_attribute   (rule 127)

    ASM 	shift, and go to state 90

    $default	reduce using rule 123 (maybeasm)

    maybeasm	go to state 196



state 176

    maybeasm  ->  ASM '(' . string ')'   (rule 124)

    STRING	shift, and go to state 57

    string	go to state 253



state 177

    notype_declarator  ->  notype_declarator '(' parmlist_or_identifiers .   (rule 158)

    $default	reduce using rule 158 (notype_declarator)



state 178

    parmlist_or_identifiers  ->  @30 . parmlist_or_identifiers_1   (rule 278)

    error	shift, and go to state 254
    IDENTIFIER	shift, and go to state 255
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    ')' 	reduce using rule 284 (parmlist_2)

    typed_declspecs	go to state 256
    declmods	go to state 257
    typespec	go to state 21
    structsp	go to state 22
    parmlist_or_identifiers_1	go to state 258
    parmlist_2	go to state 259
    parms	go to state 260
    parm	go to state 261
    identifiers	go to state 262



state 179

    notype_declarator  ->  notype_declarator '[' ']' .   (rule 162)

    $default	reduce using rule 162 (notype_declarator)



state 180

    notype_declarator  ->  notype_declarator '[' expr . ']'   (rule 161)

    ']' 	shift, and go to state 263



state 181

    errstmt  ->  error . ';'   (rule 221)

    ';' 	shift, and go to state 264



state 182

    fndef  ->  setspecs notype_declarator @7 xdecls . @8 compstmt_or_error   (rule 28)

    $default	reduce using rule 27 (@8)

    @8  	go to state 265



state 183

    xdecls  ->  decls .   (rule 88)
    decls  ->  decls . decl   (rule 91)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    $default	reduce using rule 88 (xdecls)

    decl	go to state 266
    typed_declspecs	go to state 185
    declmods	go to state 186
    typespec	go to state 21
    structsp	go to state 22



state 184

    decls  ->  decl .   (rule 89)
    decls  ->  decl . errstmt   (rule 92)

    error	shift, and go to state 181

    error	[reduce using rule 89 (decls)]
    IDENTIFIER	reduce using rule 89 (decls)
    TYPENAME	reduce using rule 89 (decls)
    SCSPEC	reduce using rule 89 (decls)
    TYPESPEC	reduce using rule 89 (decls)
    TYPE_QUAL	reduce using rule 89 (decls)
    CONSTANT	reduce using rule 89 (decls)
    STRING	reduce using rule 89 (decls)
    SIZEOF	reduce using rule 89 (decls)
    ENUM	reduce using rule 89 (decls)
    STRUCT	reduce using rule 89 (decls)
    UNION	reduce using rule 89 (decls)
    IF  	reduce using rule 89 (decls)
    WHILE	reduce using rule 89 (decls)
    DO  	reduce using rule 89 (decls)
    FOR 	reduce using rule 89 (decls)
    SWITCH	reduce using rule 89 (decls)
    CASE	reduce using rule 89 (decls)
    DEFAULT	reduce using rule 89 (decls)
    BREAK	reduce using rule 89 (decls)
    CONTINUE	reduce using rule 89 (decls)
    RETURN	reduce using rule 89 (decls)
    GOTO	reduce using rule 89 (decls)
    ASM 	reduce using rule 89 (decls)
    TYPEOF	reduce using rule 89 (decls)
    ALIGNOF	reduce using rule 89 (decls)
    '&' 	reduce using rule 89 (decls)
    '+' 	reduce using rule 89 (decls)
    '-' 	reduce using rule 89 (decls)
    '*' 	reduce using rule 89 (decls)
    PLUSPLUS	reduce using rule 89 (decls)
    MINUSMINUS	reduce using rule 89 (decls)
    '(' 	reduce using rule 89 (decls)
    ';' 	reduce using rule 89 (decls)
    '}' 	reduce using rule 89 (decls)
    '~' 	reduce using rule 89 (decls)
    '!' 	reduce using rule 89 (decls)
    '{' 	reduce using rule 89 (decls)

    errstmt	go to state 267



state 185

    decl  ->  typed_declspecs . setspecs initdecls ';'   (rule 94)
    decl  ->  typed_declspecs . ';'   (rule 96)

    ';' 	shift, and go to state 268

    $default	reduce using rule 93 (setspecs)

    setspecs	go to state 269



state 186

    decl  ->  declmods . setspecs notype_initdecls ';'   (rule 95)
    decl  ->  declmods . ';'   (rule 97)
    typed_declspecs  ->  declmods . typespec reserved_declspecs   (rule 99)
    declmods  ->  declmods . TYPE_QUAL   (rule 105)
    declmods  ->  declmods . SCSPEC   (rule 106)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 44
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 45
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 270

    $default	reduce using rule 93 (setspecs)

    setspecs	go to state 271
    typespec	go to state 48
    structsp	go to state 22



state 187

    decls  ->  errstmt .   (rule 90)

    $default	reduce using rule 90 (decls)



state 188

    maybe_attribute  ->  ATTRIBUTE . '(' '(' attribute_list ')' ')'   (rule 132)

    '(' 	shift, and go to state 272



state 189

    notype_initdcl  ->  notype_declarator maybeasm maybe_attribute . '=' @11 init   (rule 129)
    notype_initdcl  ->  notype_declarator maybeasm maybe_attribute .   (rule 130)

    '=' 	shift, and go to state 273

    $default	reduce using rule 130 (notype_initdcl)



state 190

    after_type_declarator  ->  '*' type_quals . after_type_declarator   (rule 151)
    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 160)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 206)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    TYPE_QUAL	shift, and go to state 171
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    after_type_declarator	go to state 274
    notype_declarator	go to state 172



state 191

    after_type_declarator  ->  '(' after_type_declarator . ')'   (rule 147)
    after_type_declarator  ->  after_type_declarator . '(' parmlist_or_identifiers   (rule 148)
    after_type_declarator  ->  after_type_declarator . '[' expr ']'   (rule 149)
    after_type_declarator  ->  after_type_declarator . '[' ']'   (rule 150)

    '(' 	shift, and go to state 197
    '[' 	shift, and go to state 198
    ')' 	shift, and go to state 275



state 192

    datadef  ->  typed_declspecs setspecs initdecls ';' .   (rule 12)

    $default	reduce using rule 12 (datadef)



state 193

    initdecls  ->  initdecls ',' . initdcl   (rule 120)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    initdcl	go to state 276
    declarator	go to state 175
    after_type_declarator	go to state 101
    notype_declarator	go to state 102



state 194

    fndef  ->  typed_declspecs setspecs declarator error .   (rule 21)

    $default	reduce using rule 21 (fndef)



state 195

    fndef  ->  typed_declspecs setspecs declarator @3 . xdecls @4 compstmt_or_error   (rule 20)

    error	shift, and go to state 181
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    error	[reduce using rule 87 (xdecls)]
    '{' 	reduce using rule 87 (xdecls)

    xdecls	go to state 277
    decls	go to state 183
    decl	go to state 184
    typed_declspecs	go to state 185
    declmods	go to state 186
    typespec	go to state 21
    structsp	go to state 22
    errstmt	go to state 187



state 196

    initdcl  ->  declarator maybeasm . maybe_attribute '=' @10 init   (rule 126)
    initdcl  ->  declarator maybeasm . maybe_attribute   (rule 127)

    ATTRIBUTE	shift, and go to state 188

    $default	reduce using rule 131 (maybe_attribute)

    maybe_attribute	go to state 278



state 197

    after_type_declarator  ->  after_type_declarator '(' . parmlist_or_identifiers   (rule 148)

    $default	reduce using rule 277 (@30)

    parmlist_or_identifiers	go to state 279
    @30 	go to state 178



state 198

    after_type_declarator  ->  after_type_declarator '[' . expr ']'   (rule 149)
    after_type_declarator  ->  after_type_declarator '[' . ']'   (rule 150)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    ']' 	shift, and go to state 280

    unop	go to state 73
    expr	go to state 281
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 199

    datadef  ->  declmods setspecs notype_initdecls ';' .   (rule 11)

    $default	reduce using rule 11 (datadef)



state 200

    fndef  ->  declmods setspecs notype_declarator error .   (rule 25)

    $default	reduce using rule 25 (fndef)



state 201

    fndef  ->  declmods setspecs notype_declarator @5 . xdecls @6 compstmt_or_error   (rule 24)

    error	shift, and go to state 181
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    error	[reduce using rule 87 (xdecls)]
    '{' 	reduce using rule 87 (xdecls)

    xdecls	go to state 282
    decls	go to state 183
    decl	go to state 184
    typed_declspecs	go to state 185
    declmods	go to state 186
    typespec	go to state 21
    structsp	go to state 22
    errstmt	go to state 187



state 202

    enumerator  ->  identifier '=' . expr_no_commas   (rule 198)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 283
    primary	go to state 79
    string	go to state 80



state 203

    maybecomma_warn  ->  ',' .   (rule 180)
    enumlist  ->  enumlist ',' . enumerator   (rule 196)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    $default	reduce using rule 180 (maybecomma_warn)

    identifier	go to state 111
    enumerator	go to state 284



state 204

    structsp  ->  ENUM '{' @15 enumlist maybecomma_warn . '}'   (rule 175)

    '}' 	shift, and go to state 285



state 205

    structsp  ->  ENUM identifier '{' @14 enumlist . maybecomma_warn '}'   (rule 173)
    enumlist  ->  enumlist . ',' enumerator   (rule 196)

    ',' 	shift, and go to state 203

    $default	reduce using rule 179 (maybecomma_warn)

    maybecomma_warn	go to state 286



state 206

    component_decl  ->  typed_typespecs setspecs . components   (rule 186)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    ':' 	shift, and go to state 287
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    $default	reduce using rule 189 (components)

    declarator	go to state 288
    after_type_declarator	go to state 101
    notype_declarator	go to state 102
    components	go to state 289
    component_declarator	go to state 290



state 207

    component_decl_list2  ->  component_decl_list2 component_decl ';' .   (rule 184)

    $default	reduce using rule 184 (component_decl_list2)



state 208

    component_decl  ->  nonempty_type_quals setspecs . components   (rule 187)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    ':' 	shift, and go to state 287
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    $default	reduce using rule 189 (components)

    declarator	go to state 288
    after_type_declarator	go to state 101
    notype_declarator	go to state 102
    components	go to state 291
    component_declarator	go to state 290



state 209

    structsp  ->  STRUCT identifier '{' @12 component_decl_list . '}'   (rule 165)

    '}' 	shift, and go to state 292



state 210

    structsp  ->  UNION identifier '{' @13 component_decl_list . '}'   (rule 169)

    '}' 	shift, and go to state 293



state 211

    extdef  ->  ASM '(' string ')' ';' .   (rule 9)

    $default	reduce using rule 9 (extdef)



state 212

    unary_expr  ->  SIZEOF '(' typename . ')'   (rule 48)

    ')' 	shift, and go to state 294



state 213

    unary_expr  ->  ALIGNOF '(' typename . ')'   (rule 50)

    ')' 	shift, and go to state 295



state 214

    primary  ->  '(' error ')' .   (rule 76)

    $default	reduce using rule 76 (primary)



state 215

    primary  ->  '(' expr ')' .   (rule 75)

    $default	reduce using rule 75 (primary)



state 216

    compstmt  ->  '{' . '}'   (rule 225)
    compstmt  ->  '{' . pushlevel decls xstmts '}'   (rule 226)
    compstmt  ->  '{' . pushlevel error '}'   (rule 227)
    compstmt  ->  '{' . pushlevel stmts '}'   (rule 228)

    '}' 	shift, and go to state 296

    $default	reduce using rule 222 (pushlevel)

    pushlevel	go to state 297



state 217

    primary  ->  '(' @9 compstmt . ')'   (rule 78)

    ')' 	shift, and go to state 298



state 218

    cast_expr  ->  '(' typename ')' . cast_expr   (rule 52)
    cast_expr  ->  '(' typename ')' . '{' initlist maybecomma '}'   (rule 53)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 299

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 300
    primary	go to state 79
    string	go to state 80



state 219

    nonnull_exprlist  ->  nonnull_exprlist ',' expr_no_commas .   (rule 43)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 43 (nonnull_exprlist)



state 220

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)
    expr_no_commas  ->  expr_no_commas ASSIGN expr_no_commas .   (rule 71)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 71 (expr_no_commas)



state 221

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas '=' expr_no_commas .   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 70 (expr_no_commas)



state 222

    xexpr  ->  expr .   (rule 267)

    $default	reduce using rule 267 (xexpr)



state 223

    expr_no_commas  ->  expr_no_commas '?' xexpr . ':' expr_no_commas   (rule 69)

    ':' 	shift, and go to state 301



state 224

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas OROR expr_no_commas .   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 68 (expr_no_commas)



state 225

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas ANDAND expr_no_commas .   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 67 (expr_no_commas)



state 226

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas '|' expr_no_commas .   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 65 (expr_no_commas)



state 227

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas '^' expr_no_commas .   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 66 (expr_no_commas)



state 228

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas '&' expr_no_commas .   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 64 (expr_no_commas)



state 229

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas EQCOMPARE expr_no_commas .   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 63 (expr_no_commas)



state 230

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas ARITHCOMPARE expr_no_commas .   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 62 (expr_no_commas)



state 231

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas LSHIFT expr_no_commas .   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 60 (expr_no_commas)



state 232

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas RSHIFT expr_no_commas .   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 61 (expr_no_commas)



state 233

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas '+' expr_no_commas .   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 55 (expr_no_commas)



state 234

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas '-' expr_no_commas .   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 56 (expr_no_commas)



state 235

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas '*' expr_no_commas .   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)


    $default	reduce using rule 57 (expr_no_commas)



state 236

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas '/' expr_no_commas .   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)


    $default	reduce using rule 58 (expr_no_commas)



state 237

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas '%' expr_no_commas .   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)


    $default	reduce using rule 59 (expr_no_commas)



state 238

    primary  ->  primary POINTSAT identifier .   (rule 82)

    $default	reduce using rule 82 (primary)



state 239

    primary  ->  primary '.' identifier .   (rule 81)

    $default	reduce using rule 81 (primary)



state 240

    primary  ->  primary '(' exprlist . ')'   (rule 79)

    ')' 	shift, and go to state 302



state 241

    exprlist  ->  nonnull_exprlist .   (rule 41)
    nonnull_exprlist  ->  nonnull_exprlist . ',' expr_no_commas   (rule 43)

    ',' 	shift, and go to state 137

    $default	reduce using rule 41 (exprlist)



state 242

    primary  ->  primary '[' expr . ']'   (rule 80)

    ']' 	shift, and go to state 303



state 243

    type_quals  ->  type_quals . TYPE_QUAL   (rule 206)
    absdcl1  ->  '*' type_quals . absdcl1   (rule 208)
    absdcl1  ->  '*' type_quals .   (rule 209)

    TYPE_QUAL	shift, and go to state 171
    '*' 	shift, and go to state 161
    '(' 	shift, and go to state 162
    '[' 	shift, and go to state 163

    $default	reduce using rule 209 (absdcl1)

    absdcl1	go to state 304



state 244

    absdcl1  ->  '(' absdcl1 . ')'   (rule 207)
    absdcl1  ->  absdcl1 . '(' parmlist   (rule 210)
    absdcl1  ->  absdcl1 . '[' expr ']'   (rule 211)
    absdcl1  ->  absdcl1 . '[' ']'   (rule 212)

    '(' 	shift, and go to state 249
    '[' 	shift, and go to state 250
    ')' 	shift, and go to state 305



state 245

    absdcl1  ->  '(' parmlist .   (rule 213)

    $default	reduce using rule 213 (absdcl1)



state 246

    parmlist  ->  @29 . parmlist_1   (rule 276)

    error	shift, and go to state 306
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    ')' 	reduce using rule 284 (parmlist_2)

    typed_declspecs	go to state 256
    declmods	go to state 257
    typespec	go to state 21
    structsp	go to state 22
    parmlist_1	go to state 307
    parmlist_2	go to state 308
    parms	go to state 260
    parm	go to state 261



state 247

    absdcl1  ->  '[' ']' .   (rule 215)

    $default	reduce using rule 215 (absdcl1)



state 248

    absdcl1  ->  '[' expr . ']'   (rule 214)

    ']' 	shift, and go to state 309



state 249

    absdcl1  ->  absdcl1 '(' . parmlist   (rule 210)

    $default	reduce using rule 275 (@29)

    parmlist	go to state 310
    @29 	go to state 246



state 250

    absdcl1  ->  absdcl1 '[' . expr ']'   (rule 211)
    absdcl1  ->  absdcl1 '[' . ']'   (rule 212)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    ']' 	shift, and go to state 311

    unop	go to state 73
    expr	go to state 312
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 251

    reserved_typespecquals  ->  reserved_typespecquals typespecqual_reserved .   (rule 110)

    $default	reduce using rule 110 (reserved_typespecquals)



state 252

    typed_typespecs  ->  nonempty_type_quals typespec reserved_typespecquals .   (rule 108)
    reserved_typespecquals  ->  reserved_typespecquals . typespecqual_reserved   (rule 110)

    TYPESPEC	shift, and go to state 107
    TYPE_QUAL	shift, and go to state 108
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 108 (typed_typespecs)

    typespecqual_reserved	go to state 251
    structsp	go to state 110



state 253

    string  ->  string . STRING   (rule 86)
    maybeasm  ->  ASM '(' string . ')'   (rule 124)

    STRING	shift, and go to state 124
    ')' 	shift, and go to state 313



state 254

    parmlist_or_identifiers_1  ->  error . ')'   (rule 281)

    ')' 	shift, and go to state 314



state 255

    identifiers  ->  IDENTIFIER .   (rule 294)

    $default	reduce using rule 294 (identifiers)



state 256

    parm  ->  typed_declspecs . parm_declarator   (rule 289)
    parm  ->  typed_declspecs . notype_declarator   (rule 290)
    parm  ->  typed_declspecs . absdcl   (rule 291)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 315
    '*' 	shift, and go to state 316
    '(' 	shift, and go to state 317
    '[' 	shift, and go to state 163

    $default	reduce using rule 201 (absdcl)

    parm_declarator	go to state 318
    notype_declarator	go to state 319
    absdcl	go to state 320
    absdcl1	go to state 165



state 257

    typed_declspecs  ->  declmods . typespec reserved_declspecs   (rule 99)
    declmods  ->  declmods . TYPE_QUAL   (rule 105)
    declmods  ->  declmods . SCSPEC   (rule 106)
    parm  ->  declmods . notype_declarator   (rule 292)
    parm  ->  declmods . absdcl   (rule 293)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 44
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 45
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    '*' 	shift, and go to state 321
    '(' 	shift, and go to state 317
    '[' 	shift, and go to state 163

    $default	reduce using rule 201 (absdcl)

    typespec	go to state 48
    notype_declarator	go to state 322
    structsp	go to state 22
    absdcl	go to state 323
    absdcl1	go to state 165



state 258

    parmlist_or_identifiers  ->  @30 parmlist_or_identifiers_1 .   (rule 278)

    $default	reduce using rule 278 (parmlist_or_identifiers)



state 259

    parmlist_or_identifiers_1  ->  parmlist_2 . ')'   (rule 279)

    ')' 	shift, and go to state 324



state 260

    parmlist_2  ->  parms .   (rule 285)
    parmlist_2  ->  parms . ',' ELLIPSIS   (rule 286)
    parms  ->  parms . ',' parm   (rule 288)

    ',' 	shift, and go to state 325

    $default	reduce using rule 285 (parmlist_2)



state 261

    parms  ->  parm .   (rule 287)

    $default	reduce using rule 287 (parms)



state 262

    parmlist_or_identifiers_1  ->  identifiers . ')'   (rule 280)
    identifiers  ->  identifiers . ',' IDENTIFIER   (rule 295)

    ')' 	shift, and go to state 326
    ',' 	shift, and go to state 327



state 263

    notype_declarator  ->  notype_declarator '[' expr ']' .   (rule 161)

    $default	reduce using rule 161 (notype_declarator)



state 264

    errstmt  ->  error ';' .   (rule 221)

    $default	reduce using rule 221 (errstmt)



state 265

    fndef  ->  setspecs notype_declarator @7 xdecls @8 . compstmt_or_error   (rule 28)

    error	shift, and go to state 328
    '{' 	shift, and go to state 216

    compstmt_or_error	go to state 329
    compstmt	go to state 330



state 266

    decls  ->  decls decl .   (rule 91)

    $default	reduce using rule 91 (decls)



state 267

    decls  ->  decl errstmt .   (rule 92)

    $default	reduce using rule 92 (decls)



state 268

    decl  ->  typed_declspecs ';' .   (rule 96)

    $default	reduce using rule 96 (decl)



state 269

    decl  ->  typed_declspecs setspecs . initdecls ';'   (rule 94)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    initdecls	go to state 331
    initdcl	go to state 99
    declarator	go to state 175
    after_type_declarator	go to state 101
    notype_declarator	go to state 102



state 270

    decl  ->  declmods ';' .   (rule 97)

    $default	reduce using rule 97 (decl)



state 271

    decl  ->  declmods setspecs . notype_initdecls ';'   (rule 95)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_initdecls	go to state 332
    notype_initdcl	go to state 40
    notype_declarator	go to state 333



state 272

    maybe_attribute  ->  ATTRIBUTE '(' . '(' attribute_list ')' ')'   (rule 132)

    '(' 	shift, and go to state 334



state 273

    notype_initdcl  ->  notype_declarator maybeasm maybe_attribute '=' . @11 init   (rule 129)

    $default	reduce using rule 128 (@11)

    @11 	go to state 335



state 274

    after_type_declarator  ->  after_type_declarator . '(' parmlist_or_identifiers   (rule 148)
    after_type_declarator  ->  after_type_declarator . '[' expr ']'   (rule 149)
    after_type_declarator  ->  after_type_declarator . '[' ']'   (rule 150)
    after_type_declarator  ->  '*' type_quals after_type_declarator .   (rule 151)

    '(' 	shift, and go to state 197
    '[' 	shift, and go to state 198

    $default	reduce using rule 151 (after_type_declarator)



state 275

    after_type_declarator  ->  '(' after_type_declarator ')' .   (rule 147)

    $default	reduce using rule 147 (after_type_declarator)



state 276

    initdecls  ->  initdecls ',' initdcl .   (rule 120)

    $default	reduce using rule 120 (initdecls)



state 277

    fndef  ->  typed_declspecs setspecs declarator @3 xdecls . @4 compstmt_or_error   (rule 20)

    $default	reduce using rule 19 (@4)

    @4  	go to state 336



state 278

    initdcl  ->  declarator maybeasm maybe_attribute . '=' @10 init   (rule 126)
    initdcl  ->  declarator maybeasm maybe_attribute .   (rule 127)

    '=' 	shift, and go to state 337

    $default	reduce using rule 127 (initdcl)



state 279

    after_type_declarator  ->  after_type_declarator '(' parmlist_or_identifiers .   (rule 148)

    $default	reduce using rule 148 (after_type_declarator)



state 280

    after_type_declarator  ->  after_type_declarator '[' ']' .   (rule 150)

    $default	reduce using rule 150 (after_type_declarator)



state 281

    after_type_declarator  ->  after_type_declarator '[' expr . ']'   (rule 149)

    ']' 	shift, and go to state 338



state 282

    fndef  ->  declmods setspecs notype_declarator @5 xdecls . @6 compstmt_or_error   (rule 24)

    $default	reduce using rule 23 (@6)

    @6  	go to state 339



state 283

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)
    enumerator  ->  identifier '=' expr_no_commas .   (rule 198)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 198 (enumerator)



state 284

    enumlist  ->  enumlist ',' enumerator .   (rule 196)

    $default	reduce using rule 196 (enumlist)



state 285

    structsp  ->  ENUM '{' @15 enumlist maybecomma_warn '}' .   (rule 175)

    $default	reduce using rule 175 (structsp)



state 286

    structsp  ->  ENUM identifier '{' @14 enumlist maybecomma_warn . '}'   (rule 173)

    '}' 	shift, and go to state 340



state 287

    component_declarator  ->  ':' . expr_no_commas   (rule 194)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 341
    primary	go to state 79
    string	go to state 80



state 288

    component_declarator  ->  declarator . maybe_attribute   (rule 192)
    component_declarator  ->  declarator . ':' expr_no_commas maybe_attribute   (rule 193)

    ATTRIBUTE	shift, and go to state 188
    ':' 	shift, and go to state 342

    $default	reduce using rule 131 (maybe_attribute)

    maybe_attribute	go to state 343



state 289

    component_decl  ->  typed_typespecs setspecs components .   (rule 186)
    components  ->  components . ',' component_declarator   (rule 191)

    ',' 	shift, and go to state 344

    $default	reduce using rule 186 (component_decl)



state 290

    components  ->  component_declarator .   (rule 190)

    $default	reduce using rule 190 (components)



state 291

    component_decl  ->  nonempty_type_quals setspecs components .   (rule 187)
    components  ->  components . ',' component_declarator   (rule 191)

    ',' 	shift, and go to state 344

    $default	reduce using rule 187 (component_decl)



state 292

    structsp  ->  STRUCT identifier '{' @12 component_decl_list '}' .   (rule 165)

    $default	reduce using rule 165 (structsp)



state 293

    structsp  ->  UNION identifier '{' @13 component_decl_list '}' .   (rule 169)

    $default	reduce using rule 169 (structsp)



state 294

    unary_expr  ->  SIZEOF '(' typename ')' .   (rule 48)

    $default	reduce using rule 48 (unary_expr)



state 295

    unary_expr  ->  ALIGNOF '(' typename ')' .   (rule 50)

    $default	reduce using rule 50 (unary_expr)



state 296

    compstmt  ->  '{' '}' .   (rule 225)

    $default	reduce using rule 225 (compstmt)



state 297

    compstmt  ->  '{' pushlevel . decls xstmts '}'   (rule 226)
    compstmt  ->  '{' pushlevel . error '}'   (rule 227)
    compstmt  ->  '{' pushlevel . stmts '}'   (rule 228)

    error	shift, and go to state 345
    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 347
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    decls	go to state 363
    decl	go to state 184
    typed_declspecs	go to state 185
    declmods	go to state 186
    typespec	go to state 21
    structsp	go to state 22
    stmts	go to state 364
    errstmt	go to state 187
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 367



state 298

    primary  ->  '(' @9 compstmt ')' .   (rule 78)

    $default	reduce using rule 78 (primary)



state 299

    cast_expr  ->  '(' typename ')' '{' . initlist maybecomma '}'   (rule 53)

    error	shift, and go to state 368
    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 369

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 370
    primary	go to state 79
    string	go to state 80
    init	go to state 371
    initlist	go to state 372



state 300

    cast_expr  ->  '(' typename ')' cast_expr .   (rule 52)

    $default	reduce using rule 52 (cast_expr)



state 301

    expr_no_commas  ->  expr_no_commas '?' xexpr ':' . expr_no_commas   (rule 69)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 373
    primary	go to state 79
    string	go to state 80



state 302

    primary  ->  primary '(' exprlist ')' .   (rule 79)

    $default	reduce using rule 79 (primary)



state 303

    primary  ->  primary '[' expr ']' .   (rule 80)

    $default	reduce using rule 80 (primary)



state 304

    absdcl1  ->  '*' type_quals absdcl1 .   (rule 208)
    absdcl1  ->  absdcl1 . '(' parmlist   (rule 210)
    absdcl1  ->  absdcl1 . '[' expr ']'   (rule 211)
    absdcl1  ->  absdcl1 . '[' ']'   (rule 212)

    '(' 	shift, and go to state 249
    '[' 	shift, and go to state 250

    $default	reduce using rule 208 (absdcl1)



state 305

    absdcl1  ->  '(' absdcl1 ')' .   (rule 207)

    $default	reduce using rule 207 (absdcl1)



state 306

    parmlist_1  ->  error . ')'   (rule 283)

    ')' 	shift, and go to state 374



state 307

    parmlist  ->  @29 parmlist_1 .   (rule 276)

    $default	reduce using rule 276 (parmlist)



state 308

    parmlist_1  ->  parmlist_2 . ')'   (rule 282)

    ')' 	shift, and go to state 375



state 309

    absdcl1  ->  '[' expr ']' .   (rule 214)

    $default	reduce using rule 214 (absdcl1)



state 310

    absdcl1  ->  absdcl1 '(' parmlist .   (rule 210)

    $default	reduce using rule 210 (absdcl1)



state 311

    absdcl1  ->  absdcl1 '[' ']' .   (rule 212)

    $default	reduce using rule 212 (absdcl1)



state 312

    absdcl1  ->  absdcl1 '[' expr . ']'   (rule 211)

    ']' 	shift, and go to state 376



state 313

    maybeasm  ->  ASM '(' string ')' .   (rule 124)

    $default	reduce using rule 124 (maybeasm)



state 314

    parmlist_or_identifiers_1  ->  error ')' .   (rule 281)

    $default	reduce using rule 281 (parmlist_or_identifiers_1)



state 315

    parm_declarator  ->  TYPENAME .   (rule 157)

    $default	reduce using rule 157 (parm_declarator)



state 316

    parm_declarator  ->  '*' . type_quals parm_declarator   (rule 156)
    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 160)
    absdcl1  ->  '*' . type_quals absdcl1   (rule 208)
    absdcl1  ->  '*' . type_quals   (rule 209)

    $default	reduce using rule 205 (type_quals)

    type_quals	go to state 377



state 317

    notype_declarator  ->  '(' . notype_declarator ')'   (rule 159)
    absdcl1  ->  '(' . absdcl1 ')'   (rule 207)
    absdcl1  ->  '(' . parmlist   (rule 213)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 321
    '(' 	shift, and go to state 317
    '[' 	shift, and go to state 163

    $default	reduce using rule 275 (@29)

    notype_declarator	go to state 86
    absdcl1	go to state 244
    parmlist	go to state 245
    @29 	go to state 246



state 318

    parm_declarator  ->  parm_declarator . '(' parmlist_or_identifiers   (rule 153)
    parm_declarator  ->  parm_declarator . '[' expr ']'   (rule 154)
    parm_declarator  ->  parm_declarator . '[' ']'   (rule 155)
    parm  ->  typed_declspecs parm_declarator .   (rule 289)

    '(' 	shift, and go to state 378
    '[' 	shift, and go to state 379

    $default	reduce using rule 289 (parm)



state 319

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)
    parm  ->  typed_declspecs notype_declarator .   (rule 290)

    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    $default	reduce using rule 290 (parm)



state 320

    parm  ->  typed_declspecs absdcl .   (rule 291)

    $default	reduce using rule 291 (parm)



state 321

    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 160)
    absdcl1  ->  '*' . type_quals absdcl1   (rule 208)
    absdcl1  ->  '*' . type_quals   (rule 209)

    $default	reduce using rule 205 (type_quals)

    type_quals	go to state 380



state 322

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)
    parm  ->  declmods notype_declarator .   (rule 292)

    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    $default	reduce using rule 292 (parm)



state 323

    parm  ->  declmods absdcl .   (rule 293)

    $default	reduce using rule 293 (parm)



state 324

    parmlist_or_identifiers_1  ->  parmlist_2 ')' .   (rule 279)

    $default	reduce using rule 279 (parmlist_or_identifiers_1)



state 325

    parmlist_2  ->  parms ',' . ELLIPSIS   (rule 286)
    parms  ->  parms ',' . parm   (rule 288)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ELLIPSIS	shift, and go to state 381
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    typed_declspecs	go to state 256
    declmods	go to state 257
    typespec	go to state 21
    structsp	go to state 22
    parm	go to state 382



state 326

    parmlist_or_identifiers_1  ->  identifiers ')' .   (rule 280)

    $default	reduce using rule 280 (parmlist_or_identifiers_1)



state 327

    identifiers  ->  identifiers ',' . IDENTIFIER   (rule 295)

    IDENTIFIER	shift, and go to state 383



state 328

    compstmt_or_error  ->  error . compstmt   (rule 224)

    '{' 	shift, and go to state 216

    compstmt	go to state 384



state 329

    fndef  ->  setspecs notype_declarator @7 xdecls @8 compstmt_or_error .   (rule 28)

    $default	reduce using rule 28 (fndef)



state 330

    compstmt_or_error  ->  compstmt .   (rule 223)

    $default	reduce using rule 223 (compstmt_or_error)



state 331

    decl  ->  typed_declspecs setspecs initdecls . ';'   (rule 94)
    initdecls  ->  initdecls . ',' initdcl   (rule 120)

    ';' 	shift, and go to state 385
    ',' 	shift, and go to state 193



state 332

    decl  ->  declmods setspecs notype_initdecls . ';'   (rule 95)
    notype_initdecls  ->  notype_initdecls . ',' initdcl   (rule 122)

    ';' 	shift, and go to state 386
    ',' 	shift, and go to state 88



state 333

    notype_initdcl  ->  notype_declarator . maybeasm maybe_attribute '=' @11 init   (rule 129)
    notype_initdcl  ->  notype_declarator . maybeasm maybe_attribute   (rule 130)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 158)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 161)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 162)

    ASM 	shift, and go to state 90
    '(' 	shift, and go to state 91
    '[' 	shift, and go to state 92

    $default	reduce using rule 123 (maybeasm)

    maybeasm	go to state 94



state 334

    maybe_attribute  ->  ATTRIBUTE '(' '(' . attribute_list ')' ')'   (rule 132)

    IDENTIFIER	shift, and go to state 387

    attribute_list	go to state 388
    attrib	go to state 389



state 335

    notype_initdcl  ->  notype_declarator maybeasm maybe_attribute '=' @11 . init   (rule 129)

    error	shift, and go to state 368
    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 369

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 370
    primary	go to state 79
    string	go to state 80
    init	go to state 390



state 336

    fndef  ->  typed_declspecs setspecs declarator @3 xdecls @4 . compstmt_or_error   (rule 20)

    error	shift, and go to state 328
    '{' 	shift, and go to state 216

    compstmt_or_error	go to state 391
    compstmt	go to state 330



state 337

    initdcl  ->  declarator maybeasm maybe_attribute '=' . @10 init   (rule 126)

    $default	reduce using rule 125 (@10)

    @10 	go to state 392



state 338

    after_type_declarator  ->  after_type_declarator '[' expr ']' .   (rule 149)

    $default	reduce using rule 149 (after_type_declarator)



state 339

    fndef  ->  declmods setspecs notype_declarator @5 xdecls @6 . compstmt_or_error   (rule 24)

    error	shift, and go to state 328
    '{' 	shift, and go to state 216

    compstmt_or_error	go to state 393
    compstmt	go to state 330



state 340

    structsp  ->  ENUM identifier '{' @14 enumlist maybecomma_warn '}' .   (rule 173)

    $default	reduce using rule 173 (structsp)



state 341

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)
    component_declarator  ->  ':' expr_no_commas .   (rule 194)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 194 (component_declarator)



state 342

    component_declarator  ->  declarator ':' . expr_no_commas maybe_attribute   (rule 193)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 394
    primary	go to state 79
    string	go to state 80



state 343

    component_declarator  ->  declarator maybe_attribute .   (rule 192)

    $default	reduce using rule 192 (component_declarator)



state 344

    components  ->  components ',' . component_declarator   (rule 191)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 95
    ':' 	shift, and go to state 287
    '*' 	shift, and go to state 96
    '(' 	shift, and go to state 97

    declarator	go to state 288
    after_type_declarator	go to state 101
    notype_declarator	go to state 102
    component_declarator	go to state 395



state 345

    errstmt  ->  error . ';'   (rule 221)
    compstmt  ->  '{' pushlevel error . '}'   (rule 227)

    ';' 	shift, and go to state 264
    '}' 	shift, and go to state 396



state 346

    identifier  ->  IDENTIFIER .   (rule 30)
    primary  ->  IDENTIFIER .   (rule 72)

    ':' 	reduce using rule 30 (identifier)
    $default	reduce using rule 72 (primary)



state 347

    identifier  ->  TYPENAME .   (rule 31)
    typespec  ->  TYPENAME .   (rule 113)

    ':' 	reduce using rule 31 (identifier)
    $default	reduce using rule 113 (typespec)



state 348

    simple_if  ->  IF . '(' expr ')' @16 stmt   (rule 230)

    '(' 	shift, and go to state 397



state 349

    stmt  ->  WHILE . @18 '(' expr ')' @19 stmt   (rule 238)

    $default	reduce using rule 236 (@18)

    @18 	go to state 398



state 350

    stmt  ->  DO . @20 stmt WHILE @21 '(' expr ')' ';'   (rule 241)

    $default	reduce using rule 239 (@20)

    @20 	go to state 399



state 351

    stmt  ->  FOR . '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 245)

    '(' 	shift, and go to state 400



state 352

    stmt  ->  SWITCH . '(' expr ')' @25 stmt   (rule 247)

    '(' 	shift, and go to state 401



state 353

    stmt  ->  CASE . expr ':' @26 stmt   (rule 249)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 402
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 354

    stmt  ->  DEFAULT . ':' @27 stmt   (rule 251)

    ':' 	shift, and go to state 403



state 355

    stmt  ->  BREAK . ';'   (rule 252)

    ';' 	shift, and go to state 404



state 356

    stmt  ->  CONTINUE . ';'   (rule 253)

    ';' 	shift, and go to state 405



state 357

    stmt  ->  RETURN . ';'   (rule 254)
    stmt  ->  RETURN . expr ';'   (rule 255)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 406
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 407
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 358

    stmt  ->  GOTO . identifier ';'   (rule 260)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 408



state 359

    stmt  ->  ASM . maybe_type_qual '(' string ')' ';'   (rule 256)
    stmt  ->  ASM . maybe_type_qual '(' string ':' asm_operands ')' ';'   (rule 257)
    stmt  ->  ASM . maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM . maybe_type_qual '(' string ':' asm_operands ':' asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    TYPE_QUAL	shift, and go to state 409

    $default	reduce using rule 264 (maybe_type_qual)

    maybe_type_qual	go to state 410



state 360

    stmt  ->  ';' .   (rule 263)

    $default	reduce using rule 263 (stmt)



state 361

    stmt  ->  identifier . ':' @28 stmt   (rule 262)

    ':' 	shift, and go to state 411



state 362

    stmt  ->  expr . ';'   (rule 232)

    ';' 	shift, and go to state 412



state 363

    decls  ->  decls . decl   (rule 91)
    compstmt  ->  '{' pushlevel decls . xstmts '}'   (rule 226)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 347
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    $default	reduce using rule 219 (xstmts)

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    decl	go to state 266
    typed_declspecs	go to state 185
    declmods	go to state 186
    typespec	go to state 21
    structsp	go to state 22
    stmts	go to state 413
    xstmts	go to state 414
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 367



state 364

    stmts  ->  stmts . stmt   (rule 217)
    stmts  ->  stmts . errstmt   (rule 218)
    compstmt  ->  '{' pushlevel stmts . '}'   (rule 228)

    error	shift, and go to state 181
    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '}' 	shift, and go to state 415
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    errstmt	go to state 416
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 417



state 365

    stmt  ->  compstmt .   (rule 231)

    $default	reduce using rule 231 (stmt)



state 366

    stmt  ->  simple_if . ELSE @17 stmt   (rule 234)
    stmt  ->  simple_if .   (rule 235)

    ELSE	shift, and go to state 418

    $default	reduce using rule 235 (stmt)



state 367

    stmts  ->  stmt .   (rule 216)

    $default	reduce using rule 216 (stmts)



state 368

    init  ->  error .   (rule 142)

    $default	reduce using rule 142 (init)



state 369

    init  ->  '{' . '}'   (rule 139)
    init  ->  '{' . initlist '}'   (rule 140)
    init  ->  '{' . initlist ',' '}'   (rule 141)

    error	shift, and go to state 368
    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '}' 	shift, and go to state 419
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 369

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 370
    primary	go to state 79
    string	go to state 80
    init	go to state 371
    initlist	go to state 420



state 370

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)
    init  ->  expr_no_commas .   (rule 138)

    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 138 (init)



state 371

    initlist  ->  init .   (rule 143)

    $default	reduce using rule 143 (initlist)



state 372

    cast_expr  ->  '(' typename ')' '{' initlist . maybecomma '}'   (rule 53)
    initlist  ->  initlist . ',' init   (rule 144)

    ',' 	shift, and go to state 421

    $default	reduce using rule 177 (maybecomma)

    maybecomma	go to state 422



state 373

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas '?' xexpr ':' expr_no_commas .   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)

    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 69 (expr_no_commas)



state 374

    parmlist_1  ->  error ')' .   (rule 283)

    $default	reduce using rule 283 (parmlist_1)



state 375

    parmlist_1  ->  parmlist_2 ')' .   (rule 282)

    $default	reduce using rule 282 (parmlist_1)



state 376

    absdcl1  ->  absdcl1 '[' expr ']' .   (rule 211)

    $default	reduce using rule 211 (absdcl1)



state 377

    parm_declarator  ->  '*' type_quals . parm_declarator   (rule 156)
    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 160)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 206)
    absdcl1  ->  '*' type_quals . absdcl1   (rule 208)
    absdcl1  ->  '*' type_quals .   (rule 209)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 315
    TYPE_QUAL	shift, and go to state 171
    '*' 	shift, and go to state 316
    '(' 	shift, and go to state 317
    '[' 	shift, and go to state 163

    $default	reduce using rule 209 (absdcl1)

    parm_declarator	go to state 423
    notype_declarator	go to state 172
    absdcl1	go to state 304



state 378

    parm_declarator  ->  parm_declarator '(' . parmlist_or_identifiers   (rule 153)

    $default	reduce using rule 277 (@30)

    parmlist_or_identifiers	go to state 424
    @30 	go to state 178



state 379

    parm_declarator  ->  parm_declarator '[' . expr ']'   (rule 154)
    parm_declarator  ->  parm_declarator '[' . ']'   (rule 155)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    ']' 	shift, and go to state 425

    unop	go to state 73
    expr	go to state 426
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 380

    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 160)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 206)
    absdcl1  ->  '*' type_quals . absdcl1   (rule 208)
    absdcl1  ->  '*' type_quals .   (rule 209)

    IDENTIFIER	shift, and go to state 36
    TYPE_QUAL	shift, and go to state 171
    '*' 	shift, and go to state 321
    '(' 	shift, and go to state 317
    '[' 	shift, and go to state 163

    $default	reduce using rule 209 (absdcl1)

    notype_declarator	go to state 172
    absdcl1	go to state 304



state 381

    parmlist_2  ->  parms ',' ELLIPSIS .   (rule 286)

    $default	reduce using rule 286 (parmlist_2)



state 382

    parms  ->  parms ',' parm .   (rule 288)

    $default	reduce using rule 288 (parms)



state 383

    identifiers  ->  identifiers ',' IDENTIFIER .   (rule 295)

    $default	reduce using rule 295 (identifiers)



state 384

    compstmt_or_error  ->  error compstmt .   (rule 224)

    $default	reduce using rule 224 (compstmt_or_error)



state 385

    decl  ->  typed_declspecs setspecs initdecls ';' .   (rule 94)

    $default	reduce using rule 94 (decl)



state 386

    decl  ->  declmods setspecs notype_initdecls ';' .   (rule 95)

    $default	reduce using rule 95 (decl)



state 387

    attrib  ->  IDENTIFIER .   (rule 135)
    attrib  ->  IDENTIFIER . '(' CONSTANT ')'   (rule 136)
    attrib  ->  IDENTIFIER . '(' identifiers ')'   (rule 137)

    '(' 	shift, and go to state 427

    $default	reduce using rule 135 (attrib)



state 388

    maybe_attribute  ->  ATTRIBUTE '(' '(' attribute_list . ')' ')'   (rule 132)
    attribute_list  ->  attribute_list . ',' attrib   (rule 134)

    ')' 	shift, and go to state 428
    ',' 	shift, and go to state 429



state 389

    attribute_list  ->  attrib .   (rule 133)

    $default	reduce using rule 133 (attribute_list)



state 390

    notype_initdcl  ->  notype_declarator maybeasm maybe_attribute '=' @11 init .   (rule 129)

    $default	reduce using rule 129 (notype_initdcl)



state 391

    fndef  ->  typed_declspecs setspecs declarator @3 xdecls @4 compstmt_or_error .   (rule 20)

    $default	reduce using rule 20 (fndef)



state 392

    initdcl  ->  declarator maybeasm maybe_attribute '=' @10 . init   (rule 126)

    error	shift, and go to state 368
    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 369

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 370
    primary	go to state 79
    string	go to state 80
    init	go to state 430



state 393

    fndef  ->  declmods setspecs notype_declarator @5 xdecls @6 compstmt_or_error .   (rule 24)

    $default	reduce using rule 24 (fndef)



state 394

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 70)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 71)
    component_declarator  ->  declarator ':' expr_no_commas . maybe_attribute   (rule 193)

    ATTRIBUTE	shift, and go to state 188
    ASSIGN	shift, and go to state 138
    '=' 	shift, and go to state 139
    '?' 	shift, and go to state 140
    OROR	shift, and go to state 141
    ANDAND	shift, and go to state 142
    '|' 	shift, and go to state 143
    '^' 	shift, and go to state 144
    '&' 	shift, and go to state 145
    EQCOMPARE	shift, and go to state 146
    ARITHCOMPARE	shift, and go to state 147
    LSHIFT	shift, and go to state 148
    RSHIFT	shift, and go to state 149
    '+' 	shift, and go to state 150
    '-' 	shift, and go to state 151
    '*' 	shift, and go to state 152
    '/' 	shift, and go to state 153
    '%' 	shift, and go to state 154

    $default	reduce using rule 131 (maybe_attribute)

    maybe_attribute	go to state 431



state 395

    components  ->  components ',' component_declarator .   (rule 191)

    $default	reduce using rule 191 (components)



state 396

    compstmt  ->  '{' pushlevel error '}' .   (rule 227)

    $default	reduce using rule 227 (compstmt)



state 397

    simple_if  ->  IF '(' . expr ')' @16 stmt   (rule 230)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 432
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 398

    stmt  ->  WHILE @18 . '(' expr ')' @19 stmt   (rule 238)

    '(' 	shift, and go to state 433



state 399

    stmt  ->  DO @20 . stmt WHILE @21 '(' expr ')' ';'   (rule 241)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 434



state 400

    stmt  ->  FOR '(' . xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 245)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    $default	reduce using rule 266 (xexpr)

    unop	go to state 73
    expr	go to state 222
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    xexpr	go to state 435



state 401

    stmt  ->  SWITCH '(' . expr ')' @25 stmt   (rule 247)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 436
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 402

    stmt  ->  CASE expr . ':' @26 stmt   (rule 249)

    ':' 	shift, and go to state 437



state 403

    stmt  ->  DEFAULT ':' . @27 stmt   (rule 251)

    $default	reduce using rule 250 (@27)

    @27 	go to state 438



state 404

    stmt  ->  BREAK ';' .   (rule 252)

    $default	reduce using rule 252 (stmt)



state 405

    stmt  ->  CONTINUE ';' .   (rule 253)

    $default	reduce using rule 253 (stmt)



state 406

    stmt  ->  RETURN ';' .   (rule 254)

    $default	reduce using rule 254 (stmt)



state 407

    stmt  ->  RETURN expr . ';'   (rule 255)

    ';' 	shift, and go to state 439



state 408

    stmt  ->  GOTO identifier . ';'   (rule 260)

    ';' 	shift, and go to state 440



state 409

    maybe_type_qual  ->  TYPE_QUAL .   (rule 265)

    $default	reduce using rule 265 (maybe_type_qual)



state 410

    stmt  ->  ASM maybe_type_qual . '(' string ')' ';'   (rule 256)
    stmt  ->  ASM maybe_type_qual . '(' string ':' asm_operands ')' ';'   (rule 257)
    stmt  ->  ASM maybe_type_qual . '(' string ':' asm_operands ':' asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual . '(' string ':' asm_operands ':' asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    '(' 	shift, and go to state 441



state 411

    stmt  ->  identifier ':' . @28 stmt   (rule 262)

    $default	reduce using rule 261 (@28)

    @28 	go to state 442



state 412

    stmt  ->  expr ';' .   (rule 232)

    $default	reduce using rule 232 (stmt)



state 413

    stmts  ->  stmts . stmt   (rule 217)
    stmts  ->  stmts . errstmt   (rule 218)
    xstmts  ->  stmts .   (rule 220)

    error	shift, and go to state 181
    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    '}' 	[reduce using rule 220 (xstmts)]

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    errstmt	go to state 416
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 417



state 414

    compstmt  ->  '{' pushlevel decls xstmts . '}'   (rule 226)

    '}' 	shift, and go to state 443



state 415

    compstmt  ->  '{' pushlevel stmts '}' .   (rule 228)

    $default	reduce using rule 228 (compstmt)



state 416

    stmts  ->  stmts errstmt .   (rule 218)

    $default	reduce using rule 218 (stmts)



state 417

    stmts  ->  stmts stmt .   (rule 217)

    $default	reduce using rule 217 (stmts)



state 418

    stmt  ->  simple_if ELSE . @17 stmt   (rule 234)

    $default	reduce using rule 233 (@17)

    @17 	go to state 444



state 419

    init  ->  '{' '}' .   (rule 139)

    $default	reduce using rule 139 (init)



state 420

    init  ->  '{' initlist . '}'   (rule 140)
    init  ->  '{' initlist . ',' '}'   (rule 141)
    initlist  ->  initlist . ',' init   (rule 144)

    '}' 	shift, and go to state 445
    ',' 	shift, and go to state 446



state 421

    initlist  ->  initlist ',' . init   (rule 144)
    maybecomma  ->  ',' .   (rule 178)

    error	shift, and go to state 368
    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 369

    '}' 	reduce using rule 178 (maybecomma)

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 370
    primary	go to state 79
    string	go to state 80
    init	go to state 447



state 422

    cast_expr  ->  '(' typename ')' '{' initlist maybecomma . '}'   (rule 53)

    '}' 	shift, and go to state 448



state 423

    parm_declarator  ->  parm_declarator . '(' parmlist_or_identifiers   (rule 153)
    parm_declarator  ->  parm_declarator . '[' expr ']'   (rule 154)
    parm_declarator  ->  parm_declarator . '[' ']'   (rule 155)
    parm_declarator  ->  '*' type_quals parm_declarator .   (rule 156)

    '(' 	shift, and go to state 378
    '[' 	shift, and go to state 379

    $default	reduce using rule 156 (parm_declarator)



state 424

    parm_declarator  ->  parm_declarator '(' parmlist_or_identifiers .   (rule 153)

    $default	reduce using rule 153 (parm_declarator)



state 425

    parm_declarator  ->  parm_declarator '[' ']' .   (rule 155)

    $default	reduce using rule 155 (parm_declarator)



state 426

    parm_declarator  ->  parm_declarator '[' expr . ']'   (rule 154)

    ']' 	shift, and go to state 449



state 427

    attrib  ->  IDENTIFIER '(' . CONSTANT ')'   (rule 136)
    attrib  ->  IDENTIFIER '(' . identifiers ')'   (rule 137)

    IDENTIFIER	shift, and go to state 255
    CONSTANT	shift, and go to state 450

    identifiers	go to state 451



state 428

    maybe_attribute  ->  ATTRIBUTE '(' '(' attribute_list ')' . ')'   (rule 132)

    ')' 	shift, and go to state 452



state 429

    attribute_list  ->  attribute_list ',' . attrib   (rule 134)

    IDENTIFIER	shift, and go to state 387

    attrib	go to state 453



state 430

    initdcl  ->  declarator maybeasm maybe_attribute '=' @10 init .   (rule 126)

    $default	reduce using rule 126 (initdcl)



state 431

    component_declarator  ->  declarator ':' expr_no_commas maybe_attribute .   (rule 193)

    $default	reduce using rule 193 (component_declarator)



state 432

    simple_if  ->  IF '(' expr . ')' @16 stmt   (rule 230)

    ')' 	shift, and go to state 454



state 433

    stmt  ->  WHILE @18 '(' . expr ')' @19 stmt   (rule 238)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 455
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 434

    stmt  ->  DO @20 stmt . WHILE @21 '(' expr ')' ';'   (rule 241)

    WHILE	shift, and go to state 456



state 435

    stmt  ->  FOR '(' xexpr . ';' @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 245)

    ';' 	shift, and go to state 457



state 436

    stmt  ->  SWITCH '(' expr . ')' @25 stmt   (rule 247)

    ')' 	shift, and go to state 458



state 437

    stmt  ->  CASE expr ':' . @26 stmt   (rule 249)

    $default	reduce using rule 248 (@26)

    @26 	go to state 459



state 438

    stmt  ->  DEFAULT ':' @27 . stmt   (rule 251)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 460



state 439

    stmt  ->  RETURN expr ';' .   (rule 255)

    $default	reduce using rule 255 (stmt)



state 440

    stmt  ->  GOTO identifier ';' .   (rule 260)

    $default	reduce using rule 260 (stmt)



state 441

    stmt  ->  ASM maybe_type_qual '(' . string ')' ';'   (rule 256)
    stmt  ->  ASM maybe_type_qual '(' . string ':' asm_operands ')' ';'   (rule 257)
    stmt  ->  ASM maybe_type_qual '(' . string ':' asm_operands ':' asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual '(' . string ':' asm_operands ':' asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    STRING	shift, and go to state 57

    string	go to state 461



state 442

    stmt  ->  identifier ':' @28 . stmt   (rule 262)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 462



state 443

    compstmt  ->  '{' pushlevel decls xstmts '}' .   (rule 226)

    $default	reduce using rule 226 (compstmt)



state 444

    stmt  ->  simple_if ELSE @17 . stmt   (rule 234)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 463



state 445

    init  ->  '{' initlist '}' .   (rule 140)

    $default	reduce using rule 140 (init)



state 446

    init  ->  '{' initlist ',' . '}'   (rule 141)
    initlist  ->  initlist ',' . init   (rule 144)

    error	shift, and go to state 368
    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '}' 	shift, and go to state 464
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 369

    unop	go to state 73
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 370
    primary	go to state 79
    string	go to state 80
    init	go to state 447



state 447

    initlist  ->  initlist ',' init .   (rule 144)

    $default	reduce using rule 144 (initlist)



state 448

    cast_expr  ->  '(' typename ')' '{' initlist maybecomma '}' .   (rule 53)

    $default	reduce using rule 53 (cast_expr)



state 449

    parm_declarator  ->  parm_declarator '[' expr ']' .   (rule 154)

    $default	reduce using rule 154 (parm_declarator)



state 450

    attrib  ->  IDENTIFIER '(' CONSTANT . ')'   (rule 136)

    ')' 	shift, and go to state 465



state 451

    attrib  ->  IDENTIFIER '(' identifiers . ')'   (rule 137)
    identifiers  ->  identifiers . ',' IDENTIFIER   (rule 295)

    ')' 	shift, and go to state 466
    ',' 	shift, and go to state 327



state 452

    maybe_attribute  ->  ATTRIBUTE '(' '(' attribute_list ')' ')' .   (rule 132)

    $default	reduce using rule 132 (maybe_attribute)



state 453

    attribute_list  ->  attribute_list ',' attrib .   (rule 134)

    $default	reduce using rule 134 (attribute_list)



state 454

    simple_if  ->  IF '(' expr ')' . @16 stmt   (rule 230)

    $default	reduce using rule 229 (@16)

    @16 	go to state 467



state 455

    stmt  ->  WHILE @18 '(' expr . ')' @19 stmt   (rule 238)

    ')' 	shift, and go to state 468



state 456

    stmt  ->  DO @20 stmt WHILE . @21 '(' expr ')' ';'   (rule 241)

    $default	reduce using rule 240 (@21)

    @21 	go to state 469



state 457

    stmt  ->  FOR '(' xexpr ';' . @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 245)

    $default	reduce using rule 242 (@22)

    @22 	go to state 470



state 458

    stmt  ->  SWITCH '(' expr ')' . @25 stmt   (rule 247)

    $default	reduce using rule 246 (@25)

    @25 	go to state 471



state 459

    stmt  ->  CASE expr ':' @26 . stmt   (rule 249)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 472



state 460

    stmt  ->  DEFAULT ':' @27 stmt .   (rule 251)

    $default	reduce using rule 251 (stmt)



state 461

    string  ->  string . STRING   (rule 86)
    stmt  ->  ASM maybe_type_qual '(' string . ')' ';'   (rule 256)
    stmt  ->  ASM maybe_type_qual '(' string . ':' asm_operands ')' ';'   (rule 257)
    stmt  ->  ASM maybe_type_qual '(' string . ':' asm_operands ':' asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual '(' string . ':' asm_operands ':' asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    STRING	shift, and go to state 124
    ':' 	shift, and go to state 473
    ')' 	shift, and go to state 474



state 462

    stmt  ->  identifier ':' @28 stmt .   (rule 262)

    $default	reduce using rule 262 (stmt)



state 463

    stmt  ->  simple_if ELSE @17 stmt .   (rule 234)

    $default	reduce using rule 234 (stmt)



state 464

    init  ->  '{' initlist ',' '}' .   (rule 141)

    $default	reduce using rule 141 (init)



state 465

    attrib  ->  IDENTIFIER '(' CONSTANT ')' .   (rule 136)

    $default	reduce using rule 136 (attrib)



state 466

    attrib  ->  IDENTIFIER '(' identifiers ')' .   (rule 137)

    $default	reduce using rule 137 (attrib)



state 467

    simple_if  ->  IF '(' expr ')' @16 . stmt   (rule 230)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 475



state 468

    stmt  ->  WHILE @18 '(' expr ')' . @19 stmt   (rule 238)

    $default	reduce using rule 237 (@19)

    @19 	go to state 476



state 469

    stmt  ->  DO @20 stmt WHILE @21 . '(' expr ')' ';'   (rule 241)

    '(' 	shift, and go to state 477



state 470

    stmt  ->  FOR '(' xexpr ';' @22 . xexpr ';' @23 xexpr ')' @24 stmt   (rule 245)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    $default	reduce using rule 266 (xexpr)

    unop	go to state 73
    expr	go to state 222
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    xexpr	go to state 478



state 471

    stmt  ->  SWITCH '(' expr ')' @25 . stmt   (rule 247)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 479



state 472

    stmt  ->  CASE expr ':' @26 stmt .   (rule 249)

    $default	reduce using rule 249 (stmt)



state 473

    stmt  ->  ASM maybe_type_qual '(' string ':' . asm_operands ')' ';'   (rule 257)
    stmt  ->  ASM maybe_type_qual '(' string ':' . asm_operands ':' asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual '(' string ':' . asm_operands ':' asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    STRING	shift, and go to state 480

    $default	reduce using rule 268 (asm_operands)

    asm_operands	go to state 481
    nonnull_asm_operands	go to state 482
    asm_operand	go to state 483



state 474

    stmt  ->  ASM maybe_type_qual '(' string ')' . ';'   (rule 256)

    ';' 	shift, and go to state 484



state 475

    simple_if  ->  IF '(' expr ')' @16 stmt .   (rule 230)

    $default	reduce using rule 230 (simple_if)



state 476

    stmt  ->  WHILE @18 '(' expr ')' @19 . stmt   (rule 238)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 485



state 477

    stmt  ->  DO @20 stmt WHILE @21 '(' . expr ')' ';'   (rule 241)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 486
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 478

    stmt  ->  FOR '(' xexpr ';' @22 xexpr . ';' @23 xexpr ')' @24 stmt   (rule 245)

    ';' 	shift, and go to state 487



state 479

    stmt  ->  SWITCH '(' expr ')' @25 stmt .   (rule 247)

    $default	reduce using rule 247 (stmt)



state 480

    asm_operand  ->  STRING . '(' expr ')'   (rule 272)

    '(' 	shift, and go to state 488



state 481

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands . ')' ';'   (rule 257)
    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands . ':' asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands . ':' asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    ':' 	shift, and go to state 489
    ')' 	shift, and go to state 490



state 482

    asm_operands  ->  nonnull_asm_operands .   (rule 269)
    nonnull_asm_operands  ->  nonnull_asm_operands . ',' asm_operand   (rule 271)

    ',' 	shift, and go to state 491

    $default	reduce using rule 269 (asm_operands)



state 483

    nonnull_asm_operands  ->  asm_operand .   (rule 270)

    $default	reduce using rule 270 (nonnull_asm_operands)



state 484

    stmt  ->  ASM maybe_type_qual '(' string ')' ';' .   (rule 256)

    $default	reduce using rule 256 (stmt)



state 485

    stmt  ->  WHILE @18 '(' expr ')' @19 stmt .   (rule 238)

    $default	reduce using rule 238 (stmt)



state 486

    stmt  ->  DO @20 stmt WHILE @21 '(' expr . ')' ';'   (rule 241)

    ')' 	shift, and go to state 492



state 487

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' . @23 xexpr ')' @24 stmt   (rule 245)

    $default	reduce using rule 243 (@23)

    @23 	go to state 493



state 488

    asm_operand  ->  STRING '(' . expr ')'   (rule 272)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    unop	go to state 73
    expr	go to state 494
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80



state 489

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' . asm_operands ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' . asm_operands ':' asm_clobbers ')' ';'   (rule 259)

    STRING	shift, and go to state 480

    $default	reduce using rule 268 (asm_operands)

    asm_operands	go to state 495
    nonnull_asm_operands	go to state 482
    asm_operand	go to state 483



state 490

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ')' . ';'   (rule 257)

    ';' 	shift, and go to state 496



state 491

    nonnull_asm_operands  ->  nonnull_asm_operands ',' . asm_operand   (rule 271)

    STRING	shift, and go to state 480

    asm_operand	go to state 497



state 492

    stmt  ->  DO @20 stmt WHILE @21 '(' expr ')' . ';'   (rule 241)

    ';' 	shift, and go to state 498



state 493

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 . xexpr ')' @24 stmt   (rule 245)

    IDENTIFIER	shift, and go to state 59
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72

    $default	reduce using rule 266 (xexpr)

    unop	go to state 73
    expr	go to state 222
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    xexpr	go to state 499



state 494

    asm_operand  ->  STRING '(' expr . ')'   (rule 272)

    ')' 	shift, and go to state 500



state 495

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands . ')' ';'   (rule 258)
    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands . ':' asm_clobbers ')' ';'   (rule 259)

    ':' 	shift, and go to state 501
    ')' 	shift, and go to state 502



state 496

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ')' ';' .   (rule 257)

    $default	reduce using rule 257 (stmt)



state 497

    nonnull_asm_operands  ->  nonnull_asm_operands ',' asm_operand .   (rule 271)

    $default	reduce using rule 271 (nonnull_asm_operands)



state 498

    stmt  ->  DO @20 stmt WHILE @21 '(' expr ')' ';' .   (rule 241)

    $default	reduce using rule 241 (stmt)



state 499

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr . ')' @24 stmt   (rule 245)

    ')' 	shift, and go to state 503



state 500

    asm_operand  ->  STRING '(' expr ')' .   (rule 272)

    $default	reduce using rule 272 (asm_operand)



state 501

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ':' . asm_clobbers ')' ';'   (rule 259)

    STRING	shift, and go to state 57

    string	go to state 504
    asm_clobbers	go to state 505



state 502

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' . ';'   (rule 258)

    ';' 	shift, and go to state 506



state 503

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' . @24 stmt   (rule 245)

    $default	reduce using rule 244 (@24)

    @24 	go to state 507



state 504

    string  ->  string . STRING   (rule 86)
    asm_clobbers  ->  string .   (rule 273)

    STRING	shift, and go to state 124

    $default	reduce using rule 273 (asm_clobbers)



state 505

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ':' asm_clobbers . ')' ';'   (rule 259)
    asm_clobbers  ->  asm_clobbers . ',' string   (rule 274)

    ')' 	shift, and go to state 508
    ',' 	shift, and go to state 509



state 506

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';' .   (rule 258)

    $default	reduce using rule 258 (stmt)



state 507

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 . stmt   (rule 245)

    IDENTIFIER	shift, and go to state 346
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 61
    STRING	shift, and go to state 57
    SIZEOF	shift, and go to state 62
    IF  	shift, and go to state 348
    WHILE	shift, and go to state 349
    DO  	shift, and go to state 350
    FOR 	shift, and go to state 351
    SWITCH	shift, and go to state 352
    CASE	shift, and go to state 353
    DEFAULT	shift, and go to state 354
    BREAK	shift, and go to state 355
    CONTINUE	shift, and go to state 356
    RETURN	shift, and go to state 357
    GOTO	shift, and go to state 358
    ASM 	shift, and go to state 359
    ALIGNOF	shift, and go to state 63
    '&' 	shift, and go to state 64
    '+' 	shift, and go to state 65
    '-' 	shift, and go to state 66
    '*' 	shift, and go to state 67
    PLUSPLUS	shift, and go to state 68
    MINUSMINUS	shift, and go to state 69
    '(' 	shift, and go to state 70
    ';' 	shift, and go to state 360
    '~' 	shift, and go to state 71
    '!' 	shift, and go to state 72
    '{' 	shift, and go to state 216

    identifier	go to state 361
    unop	go to state 73
    expr	go to state 362
    nonnull_exprlist	go to state 75
    unary_expr	go to state 76
    cast_expr	go to state 77
    expr_no_commas	go to state 78
    primary	go to state 79
    string	go to state 80
    compstmt	go to state 365
    simple_if	go to state 366
    stmt	go to state 510



state 508

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ':' asm_clobbers ')' . ';'   (rule 259)

    ';' 	shift, and go to state 511



state 509

    asm_clobbers  ->  asm_clobbers ',' . string   (rule 274)

    STRING	shift, and go to state 57

    string	go to state 512



state 510

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt .   (rule 245)

    $default	reduce using rule 245 (stmt)



state 511

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ':' asm_clobbers ')' ';' .   (rule 259)

    $default	reduce using rule 259 (stmt)



state 512

    string  ->  string . STRING   (rule 86)
    asm_clobbers  ->  asm_clobbers ',' string .   (rule 274)

    STRING	shift, and go to state 124

    $default	reduce using rule 274 (asm_clobbers)



state 513

    $   	go to state 514



state 514

    $   	go to state 515



state 515

    $default	accept
